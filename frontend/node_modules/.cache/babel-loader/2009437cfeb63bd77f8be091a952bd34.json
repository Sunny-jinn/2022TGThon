{"ast":null,"code":"import { liftTarget, replaceStep, canJoin, joinPoint, canSplit, ReplaceAroundStep, findWrapping } from 'prosemirror-transform';\nimport { Slice, Fragment } from 'prosemirror-model';\nimport { NodeSelection, Selection, AllSelection, TextSelection } from 'prosemirror-state';\n/**\nDelete the selection, if there is one.\n*/\n\nconst deleteSelection = (state, dispatch) => {\n  if (state.selection.empty) return false;\n  if (dispatch) dispatch(state.tr.deleteSelection().scrollIntoView());\n  return true;\n};\n/**\nIf the selection is empty and at the start of a textblock, try to\nreduce the distance between that block and the one before itâ€”if\nthere's a block directly before it that can be joined, join them.\nIf not, try to move the selected block closer to the next one in\nthe document structure by lifting it out of its parent or moving it\ninto a parent of the previous block. Will use the view for accurate\n(bidi-aware) start-of-textblock detection if given.\n*/\n\n\nconst joinBackward = (state, dispatch, view) => {\n  let {\n    $cursor\n  } = state.selection;\n  if (!$cursor || (view ? !view.endOfTextblock(\"backward\", state) : $cursor.parentOffset > 0)) return false;\n  let $cut = findCutBefore($cursor); // If there is no node before this, try to lift\n\n  if (!$cut) {\n    let range = $cursor.blockRange(),\n        target = range && liftTarget(range);\n    if (target == null) return false;\n    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());\n    return true;\n  }\n\n  let before = $cut.nodeBefore; // Apply the joining algorithm\n\n  if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch)) return true; // If the node below has no content and the node above is\n  // selectable, delete the node below and select the one above.\n\n  if ($cursor.parent.content.size == 0 && (textblockAt(before, \"end\") || NodeSelection.isSelectable(before))) {\n    let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);\n\n    if (delStep && delStep.slice.size < delStep.to - delStep.from) {\n      if (dispatch) {\n        let tr = state.tr.step(delStep);\n        tr.setSelection(textblockAt(before, \"end\") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));\n        dispatch(tr.scrollIntoView());\n      }\n\n      return true;\n    }\n  } // If the node before is an atom, delete it\n\n\n  if (before.isAtom && $cut.depth == $cursor.depth - 1) {\n    if (dispatch) dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());\n    return true;\n  }\n\n  return false;\n};\n\nfunction textblockAt(node, side) {\n  let only = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  for (let scan = node; scan; scan = side == \"start\" ? scan.firstChild : scan.lastChild) {\n    if (scan.isTextblock) return true;\n    if (only && scan.childCount != 1) return false;\n  }\n\n  return false;\n}\n/**\nWhen the selection is empty and at the start of a textblock, select\nthe node before that textblock, if possible. This is intended to be\nbound to keys like backspace, after\n[`joinBackward`](https://prosemirror.net/docs/ref/#commands.joinBackward) or other deleting\ncommands, as a fall-back behavior when the schema doesn't allow\ndeletion at the selected point.\n*/\n\n\nconst selectNodeBackward = (state, dispatch, view) => {\n  let {\n    $head,\n    empty\n  } = state.selection,\n      $cut = $head;\n  if (!empty) return false;\n\n  if ($head.parent.isTextblock) {\n    if (view ? !view.endOfTextblock(\"backward\", state) : $head.parentOffset > 0) return false;\n    $cut = findCutBefore($head);\n  }\n\n  let node = $cut && $cut.nodeBefore;\n  if (!node || !NodeSelection.isSelectable(node)) return false;\n  if (dispatch) dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());\n  return true;\n};\n\nfunction findCutBefore($pos) {\n  if (!$pos.parent.type.spec.isolating) for (let i = $pos.depth - 1; i >= 0; i--) {\n    if ($pos.index(i) > 0) return $pos.doc.resolve($pos.before(i + 1));\n    if ($pos.node(i).type.spec.isolating) break;\n  }\n  return null;\n}\n/**\nIf the selection is empty and the cursor is at the end of a\ntextblock, try to reduce or remove the boundary between that block\nand the one after it, either by joining them or by moving the other\nblock closer to this one in the tree structure. Will use the view\nfor accurate start-of-textblock detection if given.\n*/\n\n\nconst joinForward = (state, dispatch, view) => {\n  let {\n    $cursor\n  } = state.selection;\n  if (!$cursor || (view ? !view.endOfTextblock(\"forward\", state) : $cursor.parentOffset < $cursor.parent.content.size)) return false;\n  let $cut = findCutAfter($cursor); // If there is no node after this, there's nothing to do\n\n  if (!$cut) return false;\n  let after = $cut.nodeAfter; // Try the joining algorithm\n\n  if (deleteBarrier(state, $cut, dispatch)) return true; // If the node above has no content and the node below is\n  // selectable, delete the node above and select the one below.\n\n  if ($cursor.parent.content.size == 0 && (textblockAt(after, \"start\") || NodeSelection.isSelectable(after))) {\n    let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);\n\n    if (delStep && delStep.slice.size < delStep.to - delStep.from) {\n      if (dispatch) {\n        let tr = state.tr.step(delStep);\n        tr.setSelection(textblockAt(after, \"start\") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));\n        dispatch(tr.scrollIntoView());\n      }\n\n      return true;\n    }\n  } // If the next node is an atom, delete it\n\n\n  if (after.isAtom && $cut.depth == $cursor.depth - 1) {\n    if (dispatch) dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());\n    return true;\n  }\n\n  return false;\n};\n/**\nWhen the selection is empty and at the end of a textblock, select\nthe node coming after that textblock, if possible. This is intended\nto be bound to keys like delete, after\n[`joinForward`](https://prosemirror.net/docs/ref/#commands.joinForward) and similar deleting\ncommands, to provide a fall-back behavior when the schema doesn't\nallow deletion at the selected point.\n*/\n\n\nconst selectNodeForward = (state, dispatch, view) => {\n  let {\n    $head,\n    empty\n  } = state.selection,\n      $cut = $head;\n  if (!empty) return false;\n\n  if ($head.parent.isTextblock) {\n    if (view ? !view.endOfTextblock(\"forward\", state) : $head.parentOffset < $head.parent.content.size) return false;\n    $cut = findCutAfter($head);\n  }\n\n  let node = $cut && $cut.nodeAfter;\n  if (!node || !NodeSelection.isSelectable(node)) return false;\n  if (dispatch) dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());\n  return true;\n};\n\nfunction findCutAfter($pos) {\n  if (!$pos.parent.type.spec.isolating) for (let i = $pos.depth - 1; i >= 0; i--) {\n    let parent = $pos.node(i);\n    if ($pos.index(i) + 1 < parent.childCount) return $pos.doc.resolve($pos.after(i + 1));\n    if (parent.type.spec.isolating) break;\n  }\n  return null;\n}\n/**\nJoin the selected block or, if there is a text selection, the\nclosest ancestor block of the selection that can be joined, with\nthe sibling above it.\n*/\n\n\nconst joinUp = (state, dispatch) => {\n  let sel = state.selection,\n      nodeSel = sel instanceof NodeSelection,\n      point;\n\n  if (nodeSel) {\n    if (sel.node.isTextblock || !canJoin(state.doc, sel.from)) return false;\n    point = sel.from;\n  } else {\n    point = joinPoint(state.doc, sel.from, -1);\n    if (point == null) return false;\n  }\n\n  if (dispatch) {\n    let tr = state.tr.join(point);\n    if (nodeSel) tr.setSelection(NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));\n    dispatch(tr.scrollIntoView());\n  }\n\n  return true;\n};\n/**\nJoin the selected block, or the closest ancestor of the selection\nthat can be joined, with the sibling after it.\n*/\n\n\nconst joinDown = (state, dispatch) => {\n  let sel = state.selection,\n      point;\n\n  if (sel instanceof NodeSelection) {\n    if (sel.node.isTextblock || !canJoin(state.doc, sel.to)) return false;\n    point = sel.to;\n  } else {\n    point = joinPoint(state.doc, sel.to, 1);\n    if (point == null) return false;\n  }\n\n  if (dispatch) dispatch(state.tr.join(point).scrollIntoView());\n  return true;\n};\n/**\nLift the selected block, or the closest ancestor block of the\nselection that can be lifted, out of its parent node.\n*/\n\n\nconst lift = (state, dispatch) => {\n  let {\n    $from,\n    $to\n  } = state.selection;\n  let range = $from.blockRange($to),\n      target = range && liftTarget(range);\n  if (target == null) return false;\n  if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());\n  return true;\n};\n/**\nIf the selection is in a node whose type has a truthy\n[`code`](https://prosemirror.net/docs/ref/#model.NodeSpec.code) property in its spec, replace the\nselection with a newline character.\n*/\n\n\nconst newlineInCode = (state, dispatch) => {\n  let {\n    $head,\n    $anchor\n  } = state.selection;\n  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false;\n  if (dispatch) dispatch(state.tr.insertText(\"\\n\").scrollIntoView());\n  return true;\n};\n\nfunction defaultBlockAt(match) {\n  for (let i = 0; i < match.edgeCount; i++) {\n    let {\n      type\n    } = match.edge(i);\n    if (type.isTextblock && !type.hasRequiredAttrs()) return type;\n  }\n\n  return null;\n}\n/**\nWhen the selection is in a node with a truthy\n[`code`](https://prosemirror.net/docs/ref/#model.NodeSpec.code) property in its spec, create a\ndefault block after the code block, and move the cursor there.\n*/\n\n\nconst exitCode = (state, dispatch) => {\n  let {\n    $head,\n    $anchor\n  } = state.selection;\n  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false;\n  let above = $head.node(-1),\n      after = $head.indexAfter(-1),\n      type = defaultBlockAt(above.contentMatchAt(after));\n  if (!type || !above.canReplaceWith(after, after, type)) return false;\n\n  if (dispatch) {\n    let pos = $head.after(),\n        tr = state.tr.replaceWith(pos, pos, type.createAndFill());\n    tr.setSelection(Selection.near(tr.doc.resolve(pos), 1));\n    dispatch(tr.scrollIntoView());\n  }\n\n  return true;\n};\n/**\nIf a block node is selected, create an empty paragraph before (if\nit is its parent's first child) or after it.\n*/\n\n\nconst createParagraphNear = (state, dispatch) => {\n  let sel = state.selection,\n      {\n    $from,\n    $to\n  } = sel;\n  if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent) return false;\n  let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));\n  if (!type || !type.isTextblock) return false;\n\n  if (dispatch) {\n    let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;\n    let tr = state.tr.insert(side, type.createAndFill());\n    tr.setSelection(TextSelection.create(tr.doc, side + 1));\n    dispatch(tr.scrollIntoView());\n  }\n\n  return true;\n};\n/**\nIf the cursor is in an empty textblock that can be lifted, lift the\nblock.\n*/\n\n\nconst liftEmptyBlock = (state, dispatch) => {\n  let {\n    $cursor\n  } = state.selection;\n  if (!$cursor || $cursor.parent.content.size) return false;\n\n  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {\n    let before = $cursor.before();\n\n    if (canSplit(state.doc, before)) {\n      if (dispatch) dispatch(state.tr.split(before).scrollIntoView());\n      return true;\n    }\n  }\n\n  let range = $cursor.blockRange(),\n      target = range && liftTarget(range);\n  if (target == null) return false;\n  if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());\n  return true;\n};\n/**\nSplit the parent block of the selection. If the selection is a text\nselection, also delete its content.\n*/\n\n\nconst splitBlock = (state, dispatch) => {\n  let {\n    $from,\n    $to\n  } = state.selection;\n\n  if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {\n    if (!$from.parentOffset || !canSplit(state.doc, $from.pos)) return false;\n    if (dispatch) dispatch(state.tr.split($from.pos).scrollIntoView());\n    return true;\n  }\n\n  if (!$from.parent.isBlock) return false;\n\n  if (dispatch) {\n    let atEnd = $to.parentOffset == $to.parent.content.size;\n    let tr = state.tr;\n    if (state.selection instanceof TextSelection || state.selection instanceof AllSelection) tr.deleteSelection();\n    let deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));\n    let types = atEnd && deflt ? [{\n      type: deflt\n    }] : undefined;\n    let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);\n\n    if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{\n      type: deflt\n    }] : undefined)) {\n      if (deflt) types = [{\n        type: deflt\n      }];\n      can = true;\n    }\n\n    if (can) {\n      tr.split(tr.mapping.map($from.pos), 1, types);\n\n      if (!atEnd && !$from.parentOffset && $from.parent.type != deflt) {\n        let first = tr.mapping.map($from.before()),\n            $first = tr.doc.resolve(first);\n        if (deflt && $from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);\n      }\n    }\n\n    dispatch(tr.scrollIntoView());\n  }\n\n  return true;\n};\n/**\nActs like [`splitBlock`](https://prosemirror.net/docs/ref/#commands.splitBlock), but without\nresetting the set of active marks at the cursor.\n*/\n\n\nconst splitBlockKeepMarks = (state, dispatch) => {\n  return splitBlock(state, dispatch && (tr => {\n    let marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();\n    if (marks) tr.ensureMarks(marks);\n    dispatch(tr);\n  }));\n};\n/**\nMove the selection to the node wrapping the current selection, if\nany. (Will not select the document node.)\n*/\n\n\nconst selectParentNode = (state, dispatch) => {\n  let {\n    $from,\n    to\n  } = state.selection,\n      pos;\n  let same = $from.sharedDepth(to);\n  if (same == 0) return false;\n  pos = $from.before(same);\n  if (dispatch) dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos)));\n  return true;\n};\n/**\nSelect the whole document.\n*/\n\n\nconst selectAll = (state, dispatch) => {\n  if (dispatch) dispatch(state.tr.setSelection(new AllSelection(state.doc)));\n  return true;\n};\n\nfunction joinMaybeClear(state, $pos, dispatch) {\n  let before = $pos.nodeBefore,\n      after = $pos.nodeAfter,\n      index = $pos.index();\n  if (!before || !after || !before.type.compatibleContent(after.type)) return false;\n\n  if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {\n    if (dispatch) dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());\n    return true;\n  }\n\n  if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos))) return false;\n  if (dispatch) dispatch(state.tr.clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount)).join($pos.pos).scrollIntoView());\n  return true;\n}\n\nfunction deleteBarrier(state, $cut, dispatch) {\n  let before = $cut.nodeBefore,\n      after = $cut.nodeAfter,\n      conn,\n      match;\n  if (before.type.spec.isolating || after.type.spec.isolating) return false;\n  if (joinMaybeClear(state, $cut, dispatch)) return true;\n  let canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1);\n\n  if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {\n    if (dispatch) {\n      let end = $cut.pos + after.nodeSize,\n          wrap = Fragment.empty;\n\n      for (let i = conn.length - 1; i >= 0; i--) wrap = Fragment.from(conn[i].create(null, wrap));\n\n      wrap = Fragment.from(before.copy(wrap));\n      let tr = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new Slice(wrap, 1, 0), conn.length, true));\n      let joinAt = end + 2 * conn.length;\n      if (canJoin(tr.doc, joinAt)) tr.join(joinAt);\n      dispatch(tr.scrollIntoView());\n    }\n\n    return true;\n  }\n\n  let selAfter = Selection.findFrom($cut, 1);\n  let range = selAfter && selAfter.$from.blockRange(selAfter.$to),\n      target = range && liftTarget(range);\n\n  if (target != null && target >= $cut.depth) {\n    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());\n    return true;\n  }\n\n  if (canDelAfter && textblockAt(after, \"start\", true) && textblockAt(before, \"end\")) {\n    let at = before,\n        wrap = [];\n\n    for (;;) {\n      wrap.push(at);\n      if (at.isTextblock) break;\n      at = at.lastChild;\n    }\n\n    let afterText = after,\n        afterDepth = 1;\n\n    for (; !afterText.isTextblock; afterText = afterText.firstChild) afterDepth++;\n\n    if (at.canReplace(at.childCount, at.childCount, afterText.content)) {\n      if (dispatch) {\n        let end = Fragment.empty;\n\n        for (let i = wrap.length - 1; i >= 0; i--) end = Fragment.from(wrap[i].copy(end));\n\n        let tr = state.tr.step(new ReplaceAroundStep($cut.pos - wrap.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new Slice(end, wrap.length, 0), 0, true));\n        dispatch(tr.scrollIntoView());\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction selectTextblockSide(side) {\n  return function (state, dispatch) {\n    let sel = state.selection,\n        $pos = side < 0 ? sel.$from : sel.$to;\n    let depth = $pos.depth;\n\n    while ($pos.node(depth).isInline) {\n      if (!depth) return false;\n      depth--;\n    }\n\n    if (!$pos.node(depth).isTextblock) return false;\n    if (dispatch) dispatch(state.tr.setSelection(TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));\n    return true;\n  };\n}\n/**\nMoves the cursor to the start of current text block.\n*/\n\n\nconst selectTextblockStart = selectTextblockSide(-1);\n/**\nMoves the cursor to the end of current text block.\n*/\n\nconst selectTextblockEnd = selectTextblockSide(1); // Parameterized commands\n\n/**\nWrap the selection in a node of the given type with the given\nattributes.\n*/\n\nfunction wrapIn(nodeType) {\n  let attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return function (state, dispatch) {\n    let {\n      $from,\n      $to\n    } = state.selection;\n    let range = $from.blockRange($to),\n        wrapping = range && findWrapping(range, nodeType, attrs);\n    if (!wrapping) return false;\n    if (dispatch) dispatch(state.tr.wrap(range, wrapping).scrollIntoView());\n    return true;\n  };\n}\n/**\nReturns a command that tries to set the selected textblocks to the\ngiven node type with the given attributes.\n*/\n\n\nfunction setBlockType(nodeType) {\n  let attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return function (state, dispatch) {\n    let {\n      from,\n      to\n    } = state.selection;\n    let applicable = false;\n    state.doc.nodesBetween(from, to, (node, pos) => {\n      if (applicable) return false;\n      if (!node.isTextblock || node.hasMarkup(nodeType, attrs)) return;\n\n      if (node.type == nodeType) {\n        applicable = true;\n      } else {\n        let $pos = state.doc.resolve(pos),\n            index = $pos.index();\n        applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);\n      }\n    });\n    if (!applicable) return false;\n    if (dispatch) dispatch(state.tr.setBlockType(from, to, nodeType, attrs).scrollIntoView());\n    return true;\n  };\n}\n\nfunction markApplies(doc, ranges, type) {\n  for (let i = 0; i < ranges.length; i++) {\n    let {\n      $from,\n      $to\n    } = ranges[i];\n    let can = $from.depth == 0 ? doc.type.allowsMarkType(type) : false;\n    doc.nodesBetween($from.pos, $to.pos, node => {\n      if (can) return false;\n      can = node.inlineContent && node.type.allowsMarkType(type);\n    });\n    if (can) return true;\n  }\n\n  return false;\n}\n/**\nCreate a command function that toggles the given mark with the\ngiven attributes. Will return `false` when the current selection\ndoesn't support that mark. This will remove the mark if any marks\nof that type exist in the selection, or add it otherwise. If the\nselection is empty, this applies to the [stored\nmarks](https://prosemirror.net/docs/ref/#state.EditorState.storedMarks) instead of a range of the\ndocument.\n*/\n\n\nfunction toggleMark(markType) {\n  let attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return function (state, dispatch) {\n    let {\n      empty,\n      $cursor,\n      ranges\n    } = state.selection;\n    if (empty && !$cursor || !markApplies(state.doc, ranges, markType)) return false;\n\n    if (dispatch) {\n      if ($cursor) {\n        if (markType.isInSet(state.storedMarks || $cursor.marks())) dispatch(state.tr.removeStoredMark(markType));else dispatch(state.tr.addStoredMark(markType.create(attrs)));\n      } else {\n        let has = false,\n            tr = state.tr;\n\n        for (let i = 0; !has && i < ranges.length; i++) {\n          let {\n            $from,\n            $to\n          } = ranges[i];\n          has = state.doc.rangeHasMark($from.pos, $to.pos, markType);\n        }\n\n        for (let i = 0; i < ranges.length; i++) {\n          let {\n            $from,\n            $to\n          } = ranges[i];\n\n          if (has) {\n            tr.removeMark($from.pos, $to.pos, markType);\n          } else {\n            let from = $from.pos,\n                to = $to.pos,\n                start = $from.nodeAfter,\n                end = $to.nodeBefore;\n            let spaceStart = start && start.isText ? /^\\s*/.exec(start.text)[0].length : 0;\n            let spaceEnd = end && end.isText ? /\\s*$/.exec(end.text)[0].length : 0;\n\n            if (from + spaceStart < to) {\n              from += spaceStart;\n              to -= spaceEnd;\n            }\n\n            tr.addMark(from, to, markType.create(attrs));\n          }\n        }\n\n        dispatch(tr.scrollIntoView());\n      }\n    }\n\n    return true;\n  };\n}\n\nfunction wrapDispatchForJoin(dispatch, isJoinable) {\n  return tr => {\n    if (!tr.isGeneric) return dispatch(tr);\n    let ranges = [];\n\n    for (let i = 0; i < tr.mapping.maps.length; i++) {\n      let map = tr.mapping.maps[i];\n\n      for (let j = 0; j < ranges.length; j++) ranges[j] = map.map(ranges[j]);\n\n      map.forEach((_s, _e, from, to) => ranges.push(from, to));\n    } // Figure out which joinable points exist inside those ranges,\n    // by checking all node boundaries in their parent nodes.\n\n\n    let joinable = [];\n\n    for (let i = 0; i < ranges.length; i += 2) {\n      let from = ranges[i],\n          to = ranges[i + 1];\n      let $from = tr.doc.resolve(from),\n          depth = $from.sharedDepth(to),\n          parent = $from.node(depth);\n\n      for (let index = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index) {\n        let after = parent.maybeChild(index);\n        if (!after) break;\n\n        if (index && joinable.indexOf(pos) == -1) {\n          let before = parent.child(index - 1);\n          if (before.type == after.type && isJoinable(before, after)) joinable.push(pos);\n        }\n\n        pos += after.nodeSize;\n      }\n    } // Join the joinable points\n\n\n    joinable.sort((a, b) => a - b);\n\n    for (let i = joinable.length - 1; i >= 0; i--) {\n      if (canJoin(tr.doc, joinable[i])) tr.join(joinable[i]);\n    }\n\n    dispatch(tr);\n  };\n}\n/**\nWrap a command so that, when it produces a transform that causes\ntwo joinable nodes to end up next to each other, those are joined.\nNodes are considered joinable when they are of the same type and\nwhen the `isJoinable` predicate returns true for them or, if an\narray of strings was passed, if their node type name is in that\narray.\n*/\n\n\nfunction autoJoin(command, isJoinable) {\n  let canJoin = Array.isArray(isJoinable) ? node => isJoinable.indexOf(node.type.name) > -1 : isJoinable;\n  return (state, dispatch, view) => command(state, dispatch && wrapDispatchForJoin(dispatch, canJoin), view);\n}\n/**\nCombine a number of command functions into a single function (which\ncalls them one by one until one returns true).\n*/\n\n\nfunction chainCommands() {\n  for (var _len = arguments.length, commands = new Array(_len), _key = 0; _key < _len; _key++) {\n    commands[_key] = arguments[_key];\n  }\n\n  return function (state, dispatch, view) {\n    for (let i = 0; i < commands.length; i++) if (commands[i](state, dispatch, view)) return true;\n\n    return false;\n  };\n}\n\nlet backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);\nlet del = chainCommands(deleteSelection, joinForward, selectNodeForward);\n/**\nA basic keymap containing bindings not specific to any schema.\nBinds the following keys (when multiple commands are listed, they\nare chained with [`chainCommands`](https://prosemirror.net/docs/ref/#commands.chainCommands)):\n\n* **Enter** to `newlineInCode`, `createParagraphNear`, `liftEmptyBlock`, `splitBlock`\n* **Mod-Enter** to `exitCode`\n* **Backspace** and **Mod-Backspace** to `deleteSelection`, `joinBackward`, `selectNodeBackward`\n* **Delete** and **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n* **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n* **Mod-a** to `selectAll`\n*/\n\nconst pcBaseKeymap = {\n  \"Enter\": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),\n  \"Mod-Enter\": exitCode,\n  \"Backspace\": backspace,\n  \"Mod-Backspace\": backspace,\n  \"Shift-Backspace\": backspace,\n  \"Delete\": del,\n  \"Mod-Delete\": del,\n  \"Mod-a\": selectAll\n};\n/**\nA copy of `pcBaseKeymap` that also binds **Ctrl-h** like Backspace,\n**Ctrl-d** like Delete, **Alt-Backspace** like Ctrl-Backspace, and\n**Ctrl-Alt-Backspace**, **Alt-Delete**, and **Alt-d** like\nCtrl-Delete.\n*/\n\nconst macBaseKeymap = {\n  \"Ctrl-h\": pcBaseKeymap[\"Backspace\"],\n  \"Alt-Backspace\": pcBaseKeymap[\"Mod-Backspace\"],\n  \"Ctrl-d\": pcBaseKeymap[\"Delete\"],\n  \"Ctrl-Alt-Backspace\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Alt-Delete\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Alt-d\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Ctrl-a\": selectTextblockStart,\n  \"Ctrl-e\": selectTextblockEnd\n};\n\nfor (let key in pcBaseKeymap) macBaseKeymap[key] = pcBaseKeymap[key];\n\nconst mac = typeof navigator != \"undefined\" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) // @ts-ignore\n: typeof os != \"undefined\" && os.platform ? os.platform() == \"darwin\" : false;\n/**\nDepending on the detected platform, this will hold\n[`pcBasekeymap`](https://prosemirror.net/docs/ref/#commands.pcBaseKeymap) or\n[`macBaseKeymap`](https://prosemirror.net/docs/ref/#commands.macBaseKeymap).\n*/\n\nconst baseKeymap = mac ? macBaseKeymap : pcBaseKeymap;\nexport { autoJoin, baseKeymap, chainCommands, createParagraphNear, deleteSelection, exitCode, joinBackward, joinDown, joinForward, joinUp, lift, liftEmptyBlock, macBaseKeymap, newlineInCode, pcBaseKeymap, selectAll, selectNodeBackward, selectNodeForward, selectParentNode, selectTextblockEnd, selectTextblockStart, setBlockType, splitBlock, splitBlockKeepMarks, toggleMark, wrapIn };","map":null,"metadata":{},"sourceType":"module"}