{"ast":null,"code":"import { Plugin } from 'prosemirror-state';\nimport { findWrapping, canJoin } from 'prosemirror-transform';\n/**\nInput rules are regular expressions describing a piece of text\nthat, when typed, causes something to happen. This might be\nchanging two dashes into an emdash, wrapping a paragraph starting\nwith `\"> \"` into a blockquote, or something entirely different.\n*/\n\nclass InputRule {\n  // :: (RegExp, union<string, (state: EditorState, match: [string], start: number, end: number) → ?Transaction>)\n\n  /**\n  Create an input rule. The rule applies when the user typed\n  something and the text directly in front of the cursor matches\n  `match`, which should end with `$`.\n  \n  The `handler` can be a string, in which case the matched text, or\n  the first matched group in the regexp, is replaced by that\n  string.\n  \n  Or a it can be a function, which will be called with the match\n  array produced by\n  [`RegExp.exec`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec),\n  as well as the start and end of the matched range, and which can\n  return a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) that describes the\n  rule's effect, or null to indicate the input was not handled.\n  */\n  constructor(\n  /**\n  @internal\n  */\n  match, handler) {\n    this.match = match;\n    this.match = match;\n    this.handler = typeof handler == \"string\" ? stringHandler(handler) : handler;\n  }\n\n}\n\nfunction stringHandler(string) {\n  return function (state, match, start, end) {\n    let insert = string;\n\n    if (match[1]) {\n      let offset = match[0].lastIndexOf(match[1]);\n      insert += match[0].slice(offset + match[1].length);\n      start += offset;\n      let cutOff = start - end;\n\n      if (cutOff > 0) {\n        insert = match[0].slice(offset - cutOff, offset) + insert;\n        start = end;\n      }\n    }\n\n    return state.tr.insertText(insert, start, end);\n  };\n}\n\nconst MAX_MATCH = 500;\n/**\nCreate an input rules plugin. When enabled, it will cause text\ninput that matches any of the given rules to trigger the rule's\naction.\n*/\n\nfunction inputRules(_ref) {\n  let {\n    rules\n  } = _ref;\n  let plugin = new Plugin({\n    state: {\n      init() {\n        return null;\n      },\n\n      apply(tr, prev) {\n        let stored = tr.getMeta(this);\n        if (stored) return stored;\n        return tr.selectionSet || tr.docChanged ? null : prev;\n      }\n\n    },\n    props: {\n      handleTextInput(view, from, to, text) {\n        return run(view, from, to, text, rules, plugin);\n      },\n\n      handleDOMEvents: {\n        compositionend: view => {\n          setTimeout(() => {\n            let {\n              $cursor\n            } = view.state.selection;\n            if ($cursor) run(view, $cursor.pos, $cursor.pos, \"\", rules, plugin);\n          });\n        }\n      }\n    },\n    isInputRules: true\n  });\n  return plugin;\n}\n\nfunction run(view, from, to, text, rules, plugin) {\n  if (view.composing) return false;\n  let state = view.state,\n      $from = state.doc.resolve(from);\n  if ($from.parent.type.spec.code) return false;\n  let textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset, null, \"\\ufffc\") + text;\n\n  for (let i = 0; i < rules.length; i++) {\n    let match = rules[i].match.exec(textBefore);\n    let tr = match && rules[i].handler(state, match, from - (match[0].length - text.length), to);\n    if (!tr) continue;\n    view.dispatch(tr.setMeta(plugin, {\n      transform: tr,\n      from,\n      to,\n      text\n    }));\n    return true;\n  }\n\n  return false;\n}\n/**\nThis is a command that will undo an input rule, if applying such a\nrule was the last thing that the user did.\n*/\n\n\nconst undoInputRule = (state, dispatch) => {\n  let plugins = state.plugins;\n\n  for (let i = 0; i < plugins.length; i++) {\n    let plugin = plugins[i],\n        undoable;\n\n    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n      if (dispatch) {\n        let tr = state.tr,\n            toUndo = undoable.transform;\n\n        for (let j = toUndo.steps.length - 1; j >= 0; j--) tr.step(toUndo.steps[j].invert(toUndo.docs[j]));\n\n        if (undoable.text) {\n          let marks = tr.doc.resolve(undoable.from).marks();\n          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));\n        } else {\n          tr.delete(undoable.from, undoable.to);\n        }\n\n        dispatch(tr);\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\nConverts double dashes to an emdash.\n*/\n\n\nconst emDash = new InputRule(/--$/, \"—\");\n/**\nConverts three dots to an ellipsis character.\n*/\n\nconst ellipsis = new InputRule(/\\.\\.\\.$/, \"…\");\n/**\n“Smart” opening double quotes.\n*/\n\nconst openDoubleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(\")$/, \"“\");\n/**\n“Smart” closing double quotes.\n*/\n\nconst closeDoubleQuote = new InputRule(/\"$/, \"”\");\n/**\n“Smart” opening single quotes.\n*/\n\nconst openSingleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(')$/, \"‘\");\n/**\n“Smart” closing single quotes.\n*/\n\nconst closeSingleQuote = new InputRule(/'$/, \"’\");\n/**\nSmart-quote related input rules.\n*/\n\nconst smartQuotes = [openDoubleQuote, closeDoubleQuote, openSingleQuote, closeSingleQuote];\n/**\nBuild an input rule for automatically wrapping a textblock when a\ngiven string is typed. The `regexp` argument is\ndirectly passed through to the `InputRule` constructor. You'll\nprobably want the regexp to start with `^`, so that the pattern can\nonly occur at the start of a textblock.\n\n`nodeType` is the type of node to wrap in. If it needs attributes,\nyou can either pass them directly, or pass a function that will\ncompute them from the regular expression match.\n\nBy default, if there's a node with the same type above the newly\nwrapped node, the rule will try to [join](https://prosemirror.net/docs/ref/#transform.Transform.join) those\ntwo nodes. You can pass a join predicate, which takes a regular\nexpression match and the node before the wrapped node, and can\nreturn a boolean to indicate whether a join should happen.\n*/\n\nfunction wrappingInputRule(regexp, nodeType) {\n  let getAttrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  let joinPredicate = arguments.length > 3 ? arguments[3] : undefined;\n  return new InputRule(regexp, (state, match, start, end) => {\n    let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n    let tr = state.tr.delete(start, end);\n    let $start = tr.doc.resolve(start),\n        range = $start.blockRange(),\n        wrapping = range && findWrapping(range, nodeType, attrs);\n    if (!wrapping) return null;\n    tr.wrap(range, wrapping);\n    let before = tr.doc.resolve(start - 1).nodeBefore;\n    if (before && before.type == nodeType && canJoin(tr.doc, start - 1) && (!joinPredicate || joinPredicate(match, before))) tr.join(start - 1);\n    return tr;\n  });\n}\n/**\nBuild an input rule that changes the type of a textblock when the\nmatched text is typed into it. You'll usually want to start your\nregexp with `^` to that it is only matched at the start of a\ntextblock. The optional `getAttrs` parameter can be used to compute\nthe new node's attributes, and works the same as in the\n`wrappingInputRule` function.\n*/\n\n\nfunction textblockTypeInputRule(regexp, nodeType) {\n  let getAttrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return new InputRule(regexp, (state, match, start, end) => {\n    let $start = state.doc.resolve(start);\n    let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n    if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType)) return null;\n    return state.tr.delete(start, end).setBlockType(start, start, nodeType, attrs);\n  });\n}\n\nexport { InputRule, closeDoubleQuote, closeSingleQuote, ellipsis, emDash, inputRules, openDoubleQuote, openSingleQuote, smartQuotes, textblockTypeInputRule, undoInputRule, wrappingInputRule };","map":{"version":3,"names":["Plugin","findWrapping","canJoin","InputRule","constructor","match","handler","stringHandler","string","state","start","end","insert","offset","lastIndexOf","slice","length","cutOff","tr","insertText","MAX_MATCH","inputRules","rules","plugin","init","apply","prev","stored","getMeta","selectionSet","docChanged","props","handleTextInput","view","from","to","text","run","handleDOMEvents","compositionend","setTimeout","$cursor","selection","pos","isInputRules","composing","$from","doc","resolve","parent","type","spec","code","textBefore","textBetween","Math","max","parentOffset","i","exec","dispatch","setMeta","transform","undoInputRule","plugins","undoable","getState","toUndo","j","steps","step","invert","docs","marks","replaceWith","schema","delete","emDash","ellipsis","openDoubleQuote","closeDoubleQuote","openSingleQuote","closeSingleQuote","smartQuotes","wrappingInputRule","regexp","nodeType","getAttrs","joinPredicate","attrs","Function","$start","range","blockRange","wrapping","wrap","before","nodeBefore","join","textblockTypeInputRule","node","canReplaceWith","index","indexAfter","setBlockType"],"sources":["/Users/sunny/Desktop/Sunnyjin/22tgthon/frontend/node_modules/prosemirror-inputrules/dist/index.js"],"sourcesContent":["import { Plugin } from 'prosemirror-state';\nimport { findWrapping, canJoin } from 'prosemirror-transform';\n\n/**\nInput rules are regular expressions describing a piece of text\nthat, when typed, causes something to happen. This might be\nchanging two dashes into an emdash, wrapping a paragraph starting\nwith `\"> \"` into a blockquote, or something entirely different.\n*/\nclass InputRule {\n    // :: (RegExp, union<string, (state: EditorState, match: [string], start: number, end: number) → ?Transaction>)\n    /**\n    Create an input rule. The rule applies when the user typed\n    something and the text directly in front of the cursor matches\n    `match`, which should end with `$`.\n    \n    The `handler` can be a string, in which case the matched text, or\n    the first matched group in the regexp, is replaced by that\n    string.\n    \n    Or a it can be a function, which will be called with the match\n    array produced by\n    [`RegExp.exec`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec),\n    as well as the start and end of the matched range, and which can\n    return a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) that describes the\n    rule's effect, or null to indicate the input was not handled.\n    */\n    constructor(\n    /**\n    @internal\n    */\n    match, handler) {\n        this.match = match;\n        this.match = match;\n        this.handler = typeof handler == \"string\" ? stringHandler(handler) : handler;\n    }\n}\nfunction stringHandler(string) {\n    return function (state, match, start, end) {\n        let insert = string;\n        if (match[1]) {\n            let offset = match[0].lastIndexOf(match[1]);\n            insert += match[0].slice(offset + match[1].length);\n            start += offset;\n            let cutOff = start - end;\n            if (cutOff > 0) {\n                insert = match[0].slice(offset - cutOff, offset) + insert;\n                start = end;\n            }\n        }\n        return state.tr.insertText(insert, start, end);\n    };\n}\nconst MAX_MATCH = 500;\n/**\nCreate an input rules plugin. When enabled, it will cause text\ninput that matches any of the given rules to trigger the rule's\naction.\n*/\nfunction inputRules({ rules }) {\n    let plugin = new Plugin({\n        state: {\n            init() { return null; },\n            apply(tr, prev) {\n                let stored = tr.getMeta(this);\n                if (stored)\n                    return stored;\n                return tr.selectionSet || tr.docChanged ? null : prev;\n            }\n        },\n        props: {\n            handleTextInput(view, from, to, text) {\n                return run(view, from, to, text, rules, plugin);\n            },\n            handleDOMEvents: {\n                compositionend: (view) => {\n                    setTimeout(() => {\n                        let { $cursor } = view.state.selection;\n                        if ($cursor)\n                            run(view, $cursor.pos, $cursor.pos, \"\", rules, plugin);\n                    });\n                }\n            }\n        },\n        isInputRules: true\n    });\n    return plugin;\n}\nfunction run(view, from, to, text, rules, plugin) {\n    if (view.composing)\n        return false;\n    let state = view.state, $from = state.doc.resolve(from);\n    if ($from.parent.type.spec.code)\n        return false;\n    let textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset, null, \"\\ufffc\") + text;\n    for (let i = 0; i < rules.length; i++) {\n        let match = rules[i].match.exec(textBefore);\n        let tr = match && rules[i].handler(state, match, from - (match[0].length - text.length), to);\n        if (!tr)\n            continue;\n        view.dispatch(tr.setMeta(plugin, { transform: tr, from, to, text }));\n        return true;\n    }\n    return false;\n}\n/**\nThis is a command that will undo an input rule, if applying such a\nrule was the last thing that the user did.\n*/\nconst undoInputRule = (state, dispatch) => {\n    let plugins = state.plugins;\n    for (let i = 0; i < plugins.length; i++) {\n        let plugin = plugins[i], undoable;\n        if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n            if (dispatch) {\n                let tr = state.tr, toUndo = undoable.transform;\n                for (let j = toUndo.steps.length - 1; j >= 0; j--)\n                    tr.step(toUndo.steps[j].invert(toUndo.docs[j]));\n                if (undoable.text) {\n                    let marks = tr.doc.resolve(undoable.from).marks();\n                    tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));\n                }\n                else {\n                    tr.delete(undoable.from, undoable.to);\n                }\n                dispatch(tr);\n            }\n            return true;\n        }\n    }\n    return false;\n};\n\n/**\nConverts double dashes to an emdash.\n*/\nconst emDash = new InputRule(/--$/, \"—\");\n/**\nConverts three dots to an ellipsis character.\n*/\nconst ellipsis = new InputRule(/\\.\\.\\.$/, \"…\");\n/**\n“Smart” opening double quotes.\n*/\nconst openDoubleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(\")$/, \"“\");\n/**\n“Smart” closing double quotes.\n*/\nconst closeDoubleQuote = new InputRule(/\"$/, \"”\");\n/**\n“Smart” opening single quotes.\n*/\nconst openSingleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(')$/, \"‘\");\n/**\n“Smart” closing single quotes.\n*/\nconst closeSingleQuote = new InputRule(/'$/, \"’\");\n/**\nSmart-quote related input rules.\n*/\nconst smartQuotes = [openDoubleQuote, closeDoubleQuote, openSingleQuote, closeSingleQuote];\n\n/**\nBuild an input rule for automatically wrapping a textblock when a\ngiven string is typed. The `regexp` argument is\ndirectly passed through to the `InputRule` constructor. You'll\nprobably want the regexp to start with `^`, so that the pattern can\nonly occur at the start of a textblock.\n\n`nodeType` is the type of node to wrap in. If it needs attributes,\nyou can either pass them directly, or pass a function that will\ncompute them from the regular expression match.\n\nBy default, if there's a node with the same type above the newly\nwrapped node, the rule will try to [join](https://prosemirror.net/docs/ref/#transform.Transform.join) those\ntwo nodes. You can pass a join predicate, which takes a regular\nexpression match and the node before the wrapped node, and can\nreturn a boolean to indicate whether a join should happen.\n*/\nfunction wrappingInputRule(regexp, nodeType, getAttrs = null, joinPredicate) {\n    return new InputRule(regexp, (state, match, start, end) => {\n        let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n        let tr = state.tr.delete(start, end);\n        let $start = tr.doc.resolve(start), range = $start.blockRange(), wrapping = range && findWrapping(range, nodeType, attrs);\n        if (!wrapping)\n            return null;\n        tr.wrap(range, wrapping);\n        let before = tr.doc.resolve(start - 1).nodeBefore;\n        if (before && before.type == nodeType && canJoin(tr.doc, start - 1) &&\n            (!joinPredicate || joinPredicate(match, before)))\n            tr.join(start - 1);\n        return tr;\n    });\n}\n/**\nBuild an input rule that changes the type of a textblock when the\nmatched text is typed into it. You'll usually want to start your\nregexp with `^` to that it is only matched at the start of a\ntextblock. The optional `getAttrs` parameter can be used to compute\nthe new node's attributes, and works the same as in the\n`wrappingInputRule` function.\n*/\nfunction textblockTypeInputRule(regexp, nodeType, getAttrs = null) {\n    return new InputRule(regexp, (state, match, start, end) => {\n        let $start = state.doc.resolve(start);\n        let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n        if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType))\n            return null;\n        return state.tr\n            .delete(start, end)\n            .setBlockType(start, start, nodeType, attrs);\n    });\n}\n\nexport { InputRule, closeDoubleQuote, closeSingleQuote, ellipsis, emDash, inputRules, openDoubleQuote, openSingleQuote, smartQuotes, textblockTypeInputRule, undoInputRule, wrappingInputRule };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}