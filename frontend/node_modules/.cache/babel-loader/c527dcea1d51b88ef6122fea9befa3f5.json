{"ast":null,"code":"import { ReplaceError, Slice, Fragment, MarkType } from 'prosemirror-model'; // Mappable:: interface\n// There are several things that positions can be mapped through.\n// Such objects conform to this interface.\n//\n//   map:: (pos: number, assoc: ?number) → number\n//   Map a position through this object. When given, `assoc` (should\n//   be -1 or 1, defaults to 1) determines with which side the\n//   position is associated, which determines in which direction to\n//   move when a chunk of content is inserted at the mapped position.\n//\n//   mapResult:: (pos: number, assoc: ?number) → MapResult\n//   Map a position, and return an object containing additional\n//   information about the mapping. The result's `deleted` field tells\n//   you whether the position was deleted (completely enclosed in a\n//   replaced range) during the mapping. When content on only one side\n//   is deleted, the position itself is only considered deleted when\n//   `assoc` points in the direction of the deleted content.\n// Recovery values encode a range index and an offset. They are\n// represented as numbers, because tons of them will be created when\n// mapping, for example, a large number of decorations. The number's\n// lower 16 bits provide the index, the remaining bits the offset.\n//\n// Note: We intentionally don't use bit shift operators to en- and\n// decode these, since those clip to 32 bits, which we might in rare\n// cases want to overflow. A 64-bit float can represent 48-bit\n// integers precisely.\n\nvar lower16 = 0xffff;\nvar factor16 = Math.pow(2, 16);\n\nfunction makeRecover(index, offset) {\n  return index + offset * factor16;\n}\n\nfunction recoverIndex(value) {\n  return value & lower16;\n}\n\nfunction recoverOffset(value) {\n  return (value - (value & lower16)) / factor16;\n} // ::- An object representing a mapped position with extra\n// information.\n\n\nvar MapResult = function MapResult(pos, deleted, recover) {\n  if (deleted === void 0) deleted = false;\n  if (recover === void 0) recover = null; // :: number The mapped version of the position.\n\n  this.pos = pos; // :: bool Tells you whether the position was deleted, that is,\n  // whether the step removed its surroundings from the document.\n\n  this.deleted = deleted;\n  this.recover = recover;\n}; // :: class extends Mappable\n// A map describing the deletions and insertions made by a step, which\n// can be used to find the correspondence between positions in the\n// pre-step version of a document and the same position in the\n// post-step version.\n\n\nvar StepMap = function StepMap(ranges, inverted) {\n  if (inverted === void 0) inverted = false;\n\n  if (!ranges.length && StepMap.empty) {\n    return StepMap.empty;\n  }\n\n  this.ranges = ranges;\n  this.inverted = inverted;\n};\n\nStepMap.prototype.recover = function recover(value) {\n  var diff = 0,\n      index = recoverIndex(value);\n\n  if (!this.inverted) {\n    for (var i = 0; i < index; i++) {\n      diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];\n    }\n  }\n\n  return this.ranges[index * 3] + diff + recoverOffset(value);\n}; // : (number, ?number) → MapResult\n\n\nStepMap.prototype.mapResult = function mapResult(pos, assoc) {\n  if (assoc === void 0) assoc = 1;\n  return this._map(pos, assoc, false);\n}; // : (number, ?number) → number\n\n\nStepMap.prototype.map = function map(pos, assoc) {\n  if (assoc === void 0) assoc = 1;\n  return this._map(pos, assoc, true);\n};\n\nStepMap.prototype._map = function _map(pos, assoc, simple) {\n  var diff = 0,\n      oldIndex = this.inverted ? 2 : 1,\n      newIndex = this.inverted ? 1 : 2;\n\n  for (var i = 0; i < this.ranges.length; i += 3) {\n    var start = this.ranges[i] - (this.inverted ? diff : 0);\n\n    if (start > pos) {\n      break;\n    }\n\n    var oldSize = this.ranges[i + oldIndex],\n        newSize = this.ranges[i + newIndex],\n        end = start + oldSize;\n\n    if (pos <= end) {\n      var side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;\n      var result = start + diff + (side < 0 ? 0 : newSize);\n\n      if (simple) {\n        return result;\n      }\n\n      var recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);\n      return new MapResult(result, assoc < 0 ? pos != start : pos != end, recover);\n    }\n\n    diff += newSize - oldSize;\n  }\n\n  return simple ? pos + diff : new MapResult(pos + diff);\n};\n\nStepMap.prototype.touches = function touches(pos, recover) {\n  var diff = 0,\n      index = recoverIndex(recover);\n  var oldIndex = this.inverted ? 2 : 1,\n      newIndex = this.inverted ? 1 : 2;\n\n  for (var i = 0; i < this.ranges.length; i += 3) {\n    var start = this.ranges[i] - (this.inverted ? diff : 0);\n\n    if (start > pos) {\n      break;\n    }\n\n    var oldSize = this.ranges[i + oldIndex],\n        end = start + oldSize;\n\n    if (pos <= end && i == index * 3) {\n      return true;\n    }\n\n    diff += this.ranges[i + newIndex] - oldSize;\n  }\n\n  return false;\n}; // :: ((oldStart: number, oldEnd: number, newStart: number, newEnd: number))\n// Calls the given function on each of the changed ranges included in\n// this map.\n\n\nStepMap.prototype.forEach = function forEach(f) {\n  var oldIndex = this.inverted ? 2 : 1,\n      newIndex = this.inverted ? 1 : 2;\n\n  for (var i = 0, diff = 0; i < this.ranges.length; i += 3) {\n    var start = this.ranges[i],\n        oldStart = start - (this.inverted ? diff : 0),\n        newStart = start + (this.inverted ? 0 : diff);\n    var oldSize = this.ranges[i + oldIndex],\n        newSize = this.ranges[i + newIndex];\n    f(oldStart, oldStart + oldSize, newStart, newStart + newSize);\n    diff += newSize - oldSize;\n  }\n}; // :: () → StepMap\n// Create an inverted version of this map. The result can be used to\n// map positions in the post-step document to the pre-step document.\n\n\nStepMap.prototype.invert = function invert() {\n  return new StepMap(this.ranges, !this.inverted);\n};\n\nStepMap.prototype.toString = function toString() {\n  return (this.inverted ? \"-\" : \"\") + JSON.stringify(this.ranges);\n}; // :: (n: number) → StepMap\n// Create a map that moves all positions by offset `n` (which may be\n// negative). This can be useful when applying steps meant for a\n// sub-document to a larger document, or vice-versa.\n\n\nStepMap.offset = function offset(n) {\n  return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);\n};\n\nStepMap.empty = new StepMap([]); // :: class extends Mappable\n// A mapping represents a pipeline of zero or more [step\n// maps](#transform.StepMap). It has special provisions for losslessly\n// handling mapping positions through a series of steps in which some\n// steps are inverted versions of earlier steps. (This comes up when\n// ‘[rebasing](/docs/guide/#transform.rebasing)’ steps for\n// collaboration or history management.)\n\nvar Mapping = function Mapping(maps, mirror, from, to) {\n  // :: [StepMap]\n  // The step maps in this mapping.\n  this.maps = maps || []; // :: number\n  // The starting position in the `maps` array, used when `map` or\n  // `mapResult` is called.\n\n  this.from = from || 0; // :: number\n  // The end position in the `maps` array.\n\n  this.to = to == null ? this.maps.length : to;\n  this.mirror = mirror;\n}; // :: (?number, ?number) → Mapping\n// Create a mapping that maps only through a part of this one.\n\n\nMapping.prototype.slice = function slice(from, to) {\n  if (from === void 0) from = 0;\n  if (to === void 0) to = this.maps.length;\n  return new Mapping(this.maps, this.mirror, from, to);\n};\n\nMapping.prototype.copy = function copy() {\n  return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);\n}; // :: (StepMap, ?number)\n// Add a step map to the end of this mapping. If `mirrors` is\n// given, it should be the index of the step map that is the mirror\n// image of this one.\n\n\nMapping.prototype.appendMap = function appendMap(map, mirrors) {\n  this.to = this.maps.push(map);\n\n  if (mirrors != null) {\n    this.setMirror(this.maps.length - 1, mirrors);\n  }\n}; // :: (Mapping)\n// Add all the step maps in a given mapping to this one (preserving\n// mirroring information).\n\n\nMapping.prototype.appendMapping = function appendMapping(mapping) {\n  for (var i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {\n    var mirr = mapping.getMirror(i);\n    this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : null);\n  }\n}; // :: (number) → ?number\n// Finds the offset of the step map that mirrors the map at the\n// given offset, in this mapping (as per the second argument to\n// `appendMap`).\n\n\nMapping.prototype.getMirror = function getMirror(n) {\n  if (this.mirror) {\n    for (var i = 0; i < this.mirror.length; i++) {\n      if (this.mirror[i] == n) {\n        return this.mirror[i + (i % 2 ? -1 : 1)];\n      }\n    }\n  }\n};\n\nMapping.prototype.setMirror = function setMirror(n, m) {\n  if (!this.mirror) {\n    this.mirror = [];\n  }\n\n  this.mirror.push(n, m);\n}; // :: (Mapping)\n// Append the inverse of the given mapping to this one.\n\n\nMapping.prototype.appendMappingInverted = function appendMappingInverted(mapping) {\n  for (var i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {\n    var mirr = mapping.getMirror(i);\n    this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : null);\n  }\n}; // :: () → Mapping\n// Create an inverted version of this mapping.\n\n\nMapping.prototype.invert = function invert() {\n  var inverse = new Mapping();\n  inverse.appendMappingInverted(this);\n  return inverse;\n}; // : (number, ?number) → number\n// Map a position through this mapping.\n\n\nMapping.prototype.map = function map(pos, assoc) {\n  if (assoc === void 0) assoc = 1;\n\n  if (this.mirror) {\n    return this._map(pos, assoc, true);\n  }\n\n  for (var i = this.from; i < this.to; i++) {\n    pos = this.maps[i].map(pos, assoc);\n  }\n\n  return pos;\n}; // : (number, ?number) → MapResult\n// Map a position through this mapping, returning a mapping\n// result.\n\n\nMapping.prototype.mapResult = function mapResult(pos, assoc) {\n  if (assoc === void 0) assoc = 1;\n  return this._map(pos, assoc, false);\n};\n\nMapping.prototype._map = function _map(pos, assoc, simple) {\n  var deleted = false;\n\n  for (var i = this.from; i < this.to; i++) {\n    var map = this.maps[i],\n        result = map.mapResult(pos, assoc);\n\n    if (result.recover != null) {\n      var corr = this.getMirror(i);\n\n      if (corr != null && corr > i && corr < this.to) {\n        i = corr;\n        pos = this.maps[corr].recover(result.recover);\n        continue;\n      }\n    }\n\n    if (result.deleted) {\n      deleted = true;\n    }\n\n    pos = result.pos;\n  }\n\n  return simple ? pos : new MapResult(pos, deleted);\n};\n\nfunction TransformError(message) {\n  var err = Error.call(this, message);\n  err.__proto__ = TransformError.prototype;\n  return err;\n}\n\nTransformError.prototype = Object.create(Error.prototype);\nTransformError.prototype.constructor = TransformError;\nTransformError.prototype.name = \"TransformError\"; // ::- Abstraction to build up and track an array of\n// [steps](#transform.Step) representing a document transformation.\n//\n// Most transforming methods return the `Transform` object itself, so\n// that they can be chained.\n\nvar Transform = function Transform(doc) {\n  // :: Node\n  // The current document (the result of applying the steps in the\n  // transform).\n  this.doc = doc; // :: [Step]\n  // The steps in this transform.\n\n  this.steps = []; // :: [Node]\n  // The documents before each of the steps.\n\n  this.docs = []; // :: Mapping\n  // A mapping with the maps for each of the steps in this transform.\n\n  this.mapping = new Mapping();\n};\n\nvar prototypeAccessors = {\n  before: {\n    configurable: true\n  },\n  docChanged: {\n    configurable: true\n  }\n}; // :: Node The starting document.\n\nprototypeAccessors.before.get = function () {\n  return this.docs.length ? this.docs[0] : this.doc;\n}; // :: (step: Step) → this\n// Apply a new step in this transform, saving the result. Throws an\n// error when the step fails.\n\n\nTransform.prototype.step = function step(object) {\n  var result = this.maybeStep(object);\n\n  if (result.failed) {\n    throw new TransformError(result.failed);\n  }\n\n  return this;\n}; // :: (Step) → StepResult\n// Try to apply a step in this transformation, ignoring it if it\n// fails. Returns the step result.\n\n\nTransform.prototype.maybeStep = function maybeStep(step) {\n  var result = step.apply(this.doc);\n\n  if (!result.failed) {\n    this.addStep(step, result.doc);\n  }\n\n  return result;\n}; // :: bool\n// True when the document has been changed (when there are any\n// steps).\n\n\nprototypeAccessors.docChanged.get = function () {\n  return this.steps.length > 0;\n};\n\nTransform.prototype.addStep = function addStep(step, doc) {\n  this.docs.push(this.doc);\n  this.steps.push(step);\n  this.mapping.appendMap(step.getMap());\n  this.doc = doc;\n};\n\nObject.defineProperties(Transform.prototype, prototypeAccessors);\n\nfunction mustOverride() {\n  throw new Error(\"Override me\");\n}\n\nvar stepsByID = Object.create(null); // ::- A step object represents an atomic change. It generally applies\n// only to the document it was created for, since the positions\n// stored in it will only make sense for that document.\n//\n// New steps are defined by creating classes that extend `Step`,\n// overriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`\n// methods, and registering your class with a unique\n// JSON-serialization identifier using\n// [`Step.jsonID`](#transform.Step^jsonID).\n\nvar Step = function Step() {};\n\nStep.prototype.apply = function apply(_doc) {\n  return mustOverride();\n}; // :: () → StepMap\n// Get the step map that represents the changes made by this step,\n// and which can be used to transform between positions in the old\n// and the new document.\n\n\nStep.prototype.getMap = function getMap() {\n  return StepMap.empty;\n}; // :: (doc: Node) → Step\n// Create an inverted version of this step. Needs the document as it\n// was before the step as argument.\n\n\nStep.prototype.invert = function invert(_doc) {\n  return mustOverride();\n}; // :: (mapping: Mappable) → ?Step\n// Map this step through a mappable thing, returning either a\n// version of that step with its positions adjusted, or `null` if\n// the step was entirely deleted by the mapping.\n\n\nStep.prototype.map = function map(_mapping) {\n  return mustOverride();\n}; // :: (other: Step) → ?Step\n// Try to merge this step with another one, to be applied directly\n// after it. Returns the merged step when possible, null if the\n// steps can't be merged.\n\n\nStep.prototype.merge = function merge(_other) {\n  return null;\n}; // :: () → Object\n// Create a JSON-serializeable representation of this step. When\n// defining this for a custom subclass, make sure the result object\n// includes the step type's [JSON id](#transform.Step^jsonID) under\n// the `stepType` property.\n\n\nStep.prototype.toJSON = function toJSON() {\n  return mustOverride();\n}; // :: (Schema, Object) → Step\n// Deserialize a step from its JSON representation. Will call\n// through to the step class' own implementation of this method.\n\n\nStep.fromJSON = function fromJSON(schema, json) {\n  if (!json || !json.stepType) {\n    throw new RangeError(\"Invalid input for Step.fromJSON\");\n  }\n\n  var type = stepsByID[json.stepType];\n\n  if (!type) {\n    throw new RangeError(\"No step type \" + json.stepType + \" defined\");\n  }\n\n  return type.fromJSON(schema, json);\n}; // :: (string, constructor<Step>)\n// To be able to serialize steps to JSON, each step needs a string\n// ID to attach to its JSON representation. Use this method to\n// register an ID for your step classes. Try to pick something\n// that's unlikely to clash with steps from other modules.\n\n\nStep.jsonID = function jsonID(id, stepClass) {\n  if (id in stepsByID) {\n    throw new RangeError(\"Duplicate use of step JSON ID \" + id);\n  }\n\n  stepsByID[id] = stepClass;\n  stepClass.prototype.jsonID = id;\n  return stepClass;\n}; // ::- The result of [applying](#transform.Step.apply) a step. Contains either a\n// new document or a failure value.\n\n\nvar StepResult = function StepResult(doc, failed) {\n  // :: ?Node The transformed document.\n  this.doc = doc; // :: ?string Text providing information about a failed step.\n\n  this.failed = failed;\n}; // :: (Node) → StepResult\n// Create a successful step result.\n\n\nStepResult.ok = function ok(doc) {\n  return new StepResult(doc, null);\n}; // :: (string) → StepResult\n// Create a failed step result.\n\n\nStepResult.fail = function fail(message) {\n  return new StepResult(null, message);\n}; // :: (Node, number, number, Slice) → StepResult\n// Call [`Node.replace`](#model.Node.replace) with the given\n// arguments. Create a successful result if it succeeds, and a\n// failed one if it throws a `ReplaceError`.\n\n\nStepResult.fromReplace = function fromReplace(doc, from, to, slice) {\n  try {\n    return StepResult.ok(doc.replace(from, to, slice));\n  } catch (e) {\n    if (e instanceof ReplaceError) {\n      return StepResult.fail(e.message);\n    }\n\n    throw e;\n  }\n}; // ::- Replace a part of the document with a slice of new content.\n\n\nvar ReplaceStep = /*@__PURE__*/function (Step) {\n  function ReplaceStep(from, to, slice, structure) {\n    Step.call(this); // :: number\n    // The start position of the replaced range.\n\n    this.from = from; // :: number\n    // The end position of the replaced range.\n\n    this.to = to; // :: Slice\n    // The slice to insert.\n\n    this.slice = slice;\n    this.structure = !!structure;\n  }\n\n  if (Step) ReplaceStep.__proto__ = Step;\n  ReplaceStep.prototype = Object.create(Step && Step.prototype);\n  ReplaceStep.prototype.constructor = ReplaceStep;\n\n  ReplaceStep.prototype.apply = function apply(doc) {\n    if (this.structure && contentBetween(doc, this.from, this.to)) {\n      return StepResult.fail(\"Structure replace would overwrite content\");\n    }\n\n    return StepResult.fromReplace(doc, this.from, this.to, this.slice);\n  };\n\n  ReplaceStep.prototype.getMap = function getMap() {\n    return new StepMap([this.from, this.to - this.from, this.slice.size]);\n  };\n\n  ReplaceStep.prototype.invert = function invert(doc) {\n    return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to));\n  };\n\n  ReplaceStep.prototype.map = function map(mapping) {\n    var from = mapping.mapResult(this.from, 1),\n        to = mapping.mapResult(this.to, -1);\n\n    if (from.deleted && to.deleted) {\n      return null;\n    }\n\n    return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice);\n  };\n\n  ReplaceStep.prototype.merge = function merge(other) {\n    if (!(other instanceof ReplaceStep) || other.structure || this.structure) {\n      return null;\n    }\n\n    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {\n      var slice = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);\n      return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure);\n    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {\n      var slice$1 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);\n      return new ReplaceStep(other.from, this.to, slice$1, this.structure);\n    } else {\n      return null;\n    }\n  };\n\n  ReplaceStep.prototype.toJSON = function toJSON() {\n    var json = {\n      stepType: \"replace\",\n      from: this.from,\n      to: this.to\n    };\n\n    if (this.slice.size) {\n      json.slice = this.slice.toJSON();\n    }\n\n    if (this.structure) {\n      json.structure = true;\n    }\n\n    return json;\n  };\n\n  ReplaceStep.fromJSON = function fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\") {\n      throw new RangeError(\"Invalid input for ReplaceStep.fromJSON\");\n    }\n\n    return new ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure);\n  };\n\n  return ReplaceStep;\n}(Step);\n\nStep.jsonID(\"replace\", ReplaceStep); // ::- Replace a part of the document with a slice of content, but\n// preserve a range of the replaced content by moving it into the\n// slice.\n\nvar ReplaceAroundStep = /*@__PURE__*/function (Step) {\n  function ReplaceAroundStep(from, to, gapFrom, gapTo, slice, insert, structure) {\n    Step.call(this); // :: number\n    // The start position of the replaced range.\n\n    this.from = from; // :: number\n    // The end position of the replaced range.\n\n    this.to = to; // :: number\n    // The start of preserved range.\n\n    this.gapFrom = gapFrom; // :: number\n    // The end of preserved range.\n\n    this.gapTo = gapTo; // :: Slice\n    // The slice to insert.\n\n    this.slice = slice; // :: number\n    // The position in the slice where the preserved range should be\n    // inserted.\n\n    this.insert = insert;\n    this.structure = !!structure;\n  }\n\n  if (Step) ReplaceAroundStep.__proto__ = Step;\n  ReplaceAroundStep.prototype = Object.create(Step && Step.prototype);\n  ReplaceAroundStep.prototype.constructor = ReplaceAroundStep;\n\n  ReplaceAroundStep.prototype.apply = function apply(doc) {\n    if (this.structure && (contentBetween(doc, this.from, this.gapFrom) || contentBetween(doc, this.gapTo, this.to))) {\n      return StepResult.fail(\"Structure gap-replace would overwrite content\");\n    }\n\n    var gap = doc.slice(this.gapFrom, this.gapTo);\n\n    if (gap.openStart || gap.openEnd) {\n      return StepResult.fail(\"Gap is not a flat range\");\n    }\n\n    var inserted = this.slice.insertAt(this.insert, gap.content);\n\n    if (!inserted) {\n      return StepResult.fail(\"Content does not fit in gap\");\n    }\n\n    return StepResult.fromReplace(doc, this.from, this.to, inserted);\n  };\n\n  ReplaceAroundStep.prototype.getMap = function getMap() {\n    return new StepMap([this.from, this.gapFrom - this.from, this.insert, this.gapTo, this.to - this.gapTo, this.slice.size - this.insert]);\n  };\n\n  ReplaceAroundStep.prototype.invert = function invert(doc) {\n    var gap = this.gapTo - this.gapFrom;\n    return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);\n  };\n\n  ReplaceAroundStep.prototype.map = function map(mapping) {\n    var from = mapping.mapResult(this.from, 1),\n        to = mapping.mapResult(this.to, -1);\n    var gapFrom = mapping.map(this.gapFrom, -1),\n        gapTo = mapping.map(this.gapTo, 1);\n\n    if (from.deleted && to.deleted || gapFrom < from.pos || gapTo > to.pos) {\n      return null;\n    }\n\n    return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);\n  };\n\n  ReplaceAroundStep.prototype.toJSON = function toJSON() {\n    var json = {\n      stepType: \"replaceAround\",\n      from: this.from,\n      to: this.to,\n      gapFrom: this.gapFrom,\n      gapTo: this.gapTo,\n      insert: this.insert\n    };\n\n    if (this.slice.size) {\n      json.slice = this.slice.toJSON();\n    }\n\n    if (this.structure) {\n      json.structure = true;\n    }\n\n    return json;\n  };\n\n  ReplaceAroundStep.fromJSON = function fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\" || typeof json.gapFrom != \"number\" || typeof json.gapTo != \"number\" || typeof json.insert != \"number\") {\n      throw new RangeError(\"Invalid input for ReplaceAroundStep.fromJSON\");\n    }\n\n    return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);\n  };\n\n  return ReplaceAroundStep;\n}(Step);\n\nStep.jsonID(\"replaceAround\", ReplaceAroundStep);\n\nfunction contentBetween(doc, from, to) {\n  var $from = doc.resolve(from),\n      dist = to - from,\n      depth = $from.depth;\n\n  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {\n    depth--;\n    dist--;\n  }\n\n  if (dist > 0) {\n    var next = $from.node(depth).maybeChild($from.indexAfter(depth));\n\n    while (dist > 0) {\n      if (!next || next.isLeaf) {\n        return true;\n      }\n\n      next = next.firstChild;\n      dist--;\n    }\n  }\n\n  return false;\n}\n\nfunction canCut(node, start, end) {\n  return (start == 0 || node.canReplace(start, node.childCount)) && (end == node.childCount || node.canReplace(0, end));\n} // :: (NodeRange) → ?number\n// Try to find a target depth to which the content in the given range\n// can be lifted. Will not go across\n// [isolating](#model.NodeSpec.isolating) parent nodes.\n\n\nfunction liftTarget(range) {\n  var parent = range.parent;\n  var content = parent.content.cutByIndex(range.startIndex, range.endIndex);\n\n  for (var depth = range.depth;; --depth) {\n    var node = range.$from.node(depth);\n    var index = range.$from.index(depth),\n        endIndex = range.$to.indexAfter(depth);\n\n    if (depth < range.depth && node.canReplace(index, endIndex, content)) {\n      return depth;\n    }\n\n    if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex)) {\n      break;\n    }\n  }\n} // :: (NodeRange, number) → this\n// Split the content in the given range off from its parent, if there\n// is sibling content before or after it, and move it up the tree to\n// the depth specified by `target`. You'll probably want to use\n// [`liftTarget`](#transform.liftTarget) to compute `target`, to make\n// sure the lift is valid.\n\n\nTransform.prototype.lift = function (range, target) {\n  var $from = range.$from;\n  var $to = range.$to;\n  var depth = range.depth;\n  var gapStart = $from.before(depth + 1),\n      gapEnd = $to.after(depth + 1);\n  var start = gapStart,\n      end = gapEnd;\n  var before = Fragment.empty,\n      openStart = 0;\n\n  for (var d = depth, splitting = false; d > target; d--) {\n    if (splitting || $from.index(d) > 0) {\n      splitting = true;\n      before = Fragment.from($from.node(d).copy(before));\n      openStart++;\n    } else {\n      start--;\n    }\n  }\n\n  var after = Fragment.empty,\n      openEnd = 0;\n\n  for (var d$1 = depth, splitting$1 = false; d$1 > target; d$1--) {\n    if (splitting$1 || $to.after(d$1 + 1) < $to.end(d$1)) {\n      splitting$1 = true;\n      after = Fragment.from($to.node(d$1).copy(after));\n      openEnd++;\n    } else {\n      end++;\n    }\n  }\n\n  return this.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new Slice(before.append(after), openStart, openEnd), before.size - openStart, true));\n}; // :: (NodeRange, NodeType, ?Object, ?NodeRange) → ?[{type: NodeType, attrs: ?Object}]\n// Try to find a valid way to wrap the content in the given range in a\n// node of the given type. May introduce extra nodes around and inside\n// the wrapper node, if necessary. Returns null if no valid wrapping\n// could be found. When `innerRange` is given, that range's content is\n// used as the content to fit into the wrapping, instead of the\n// content of `range`.\n\n\nfunction findWrapping(range, nodeType, attrs, innerRange) {\n  if (innerRange === void 0) innerRange = range;\n  var around = findWrappingOutside(range, nodeType);\n  var inner = around && findWrappingInside(innerRange, nodeType);\n\n  if (!inner) {\n    return null;\n  }\n\n  return around.map(withAttrs).concat({\n    type: nodeType,\n    attrs: attrs\n  }).concat(inner.map(withAttrs));\n}\n\nfunction withAttrs(type) {\n  return {\n    type: type,\n    attrs: null\n  };\n}\n\nfunction findWrappingOutside(range, type) {\n  var parent = range.parent;\n  var startIndex = range.startIndex;\n  var endIndex = range.endIndex;\n  var around = parent.contentMatchAt(startIndex).findWrapping(type);\n\n  if (!around) {\n    return null;\n  }\n\n  var outer = around.length ? around[0] : type;\n  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;\n}\n\nfunction findWrappingInside(range, type) {\n  var parent = range.parent;\n  var startIndex = range.startIndex;\n  var endIndex = range.endIndex;\n  var inner = parent.child(startIndex);\n  var inside = type.contentMatch.findWrapping(inner.type);\n\n  if (!inside) {\n    return null;\n  }\n\n  var lastType = inside.length ? inside[inside.length - 1] : type;\n  var innerMatch = lastType.contentMatch;\n\n  for (var i = startIndex; innerMatch && i < endIndex; i++) {\n    innerMatch = innerMatch.matchType(parent.child(i).type);\n  }\n\n  if (!innerMatch || !innerMatch.validEnd) {\n    return null;\n  }\n\n  return inside;\n} // :: (NodeRange, [{type: NodeType, attrs: ?Object}]) → this\n// Wrap the given [range](#model.NodeRange) in the given set of wrappers.\n// The wrappers are assumed to be valid in this position, and should\n// probably be computed with [`findWrapping`](#transform.findWrapping).\n\n\nTransform.prototype.wrap = function (range, wrappers) {\n  var content = Fragment.empty;\n\n  for (var i = wrappers.length - 1; i >= 0; i--) {\n    if (content.size) {\n      var match = wrappers[i].type.contentMatch.matchFragment(content);\n\n      if (!match || !match.validEnd) {\n        throw new RangeError(\"Wrapper type given to Transform.wrap does not form valid content of its parent wrapper\");\n      }\n    }\n\n    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\n  }\n\n  var start = range.start,\n      end = range.end;\n  return this.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true));\n}; // :: (number, ?number, NodeType, ?Object) → this\n// Set the type of all textblocks (partly) between `from` and `to` to\n// the given node type with the given attributes.\n\n\nTransform.prototype.setBlockType = function (from, to, type, attrs) {\n  var this$1 = this;\n  if (to === void 0) to = from;\n\n  if (!type.isTextblock) {\n    throw new RangeError(\"Type given to setBlockType should be a textblock\");\n  }\n\n  var mapFrom = this.steps.length;\n  this.doc.nodesBetween(from, to, function (node, pos) {\n    if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(this$1.doc, this$1.mapping.slice(mapFrom).map(pos), type)) {\n      // Ensure all markup that isn't allowed in the new node type is cleared\n      this$1.clearIncompatible(this$1.mapping.slice(mapFrom).map(pos, 1), type);\n      var mapping = this$1.mapping.slice(mapFrom);\n      var startM = mapping.map(pos, 1),\n          endM = mapping.map(pos + node.nodeSize, 1);\n      this$1.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true));\n      return false;\n    }\n  });\n  return this;\n};\n\nfunction canChangeType(doc, pos, type) {\n  var $pos = doc.resolve(pos),\n      index = $pos.index();\n  return $pos.parent.canReplaceWith(index, index + 1, type);\n} // :: (number, ?NodeType, ?Object, ?[Mark]) → this\n// Change the type, attributes, and/or marks of the node at `pos`.\n// When `type` isn't given, the existing node type is preserved,\n\n\nTransform.prototype.setNodeMarkup = function (pos, type, attrs, marks) {\n  var node = this.doc.nodeAt(pos);\n\n  if (!node) {\n    throw new RangeError(\"No node at given position\");\n  }\n\n  if (!type) {\n    type = node.type;\n  }\n\n  var newNode = type.create(attrs, null, marks || node.marks);\n\n  if (node.isLeaf) {\n    return this.replaceWith(pos, pos + node.nodeSize, newNode);\n  }\n\n  if (!type.validContent(node.content)) {\n    throw new RangeError(\"Invalid content for node type \" + type.name);\n  }\n\n  return this.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new Slice(Fragment.from(newNode), 0, 0), 1, true));\n}; // :: (Node, number, number, ?[?{type: NodeType, attrs: ?Object}]) → bool\n// Check whether splitting at the given position is allowed.\n\n\nfunction canSplit(doc, pos, depth, typesAfter) {\n  if (depth === void 0) depth = 1;\n  var $pos = doc.resolve(pos),\n      base = $pos.depth - depth;\n  var innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;\n\n  if (base < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount))) {\n    return false;\n  }\n\n  for (var d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {\n    var node = $pos.node(d),\n        index$1 = $pos.index(d);\n\n    if (node.type.spec.isolating) {\n      return false;\n    }\n\n    var rest = node.content.cutByIndex(index$1, node.childCount);\n    var after = typesAfter && typesAfter[i] || node;\n\n    if (after != node) {\n      rest = rest.replaceChild(0, after.type.create(after.attrs));\n    }\n\n    if (!node.canReplace(index$1 + 1, node.childCount) || !after.type.validContent(rest)) {\n      return false;\n    }\n  }\n\n  var index = $pos.indexAfter(base);\n  var baseType = typesAfter && typesAfter[0];\n  return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type);\n} // :: (number, ?number, ?[?{type: NodeType, attrs: ?Object}]) → this\n// Split the node at the given position, and optionally, if `depth` is\n// greater than one, any number of nodes above that. By default, the\n// parts split off will inherit the node type of the original node.\n// This can be changed by passing an array of types and attributes to\n// use after the split.\n\n\nTransform.prototype.split = function (pos, depth, typesAfter) {\n  if (depth === void 0) depth = 1;\n  var $pos = this.doc.resolve(pos),\n      before = Fragment.empty,\n      after = Fragment.empty;\n\n  for (var d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {\n    before = Fragment.from($pos.node(d).copy(before));\n    var typeAfter = typesAfter && typesAfter[i];\n    after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));\n  }\n\n  return this.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true));\n}; // :: (Node, number) → bool\n// Test whether the blocks before and after a given position can be\n// joined.\n\n\nfunction canJoin(doc, pos) {\n  var $pos = doc.resolve(pos),\n      index = $pos.index();\n  return joinable($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index, index + 1);\n}\n\nfunction joinable(a, b) {\n  return a && b && !a.isLeaf && a.canAppend(b);\n} // :: (Node, number, ?number) → ?number\n// Find an ancestor of the given position that can be joined to the\n// block before (or after if `dir` is positive). Returns the joinable\n// point, if any.\n\n\nfunction joinPoint(doc, pos, dir) {\n  if (dir === void 0) dir = -1;\n  var $pos = doc.resolve(pos);\n\n  for (var d = $pos.depth;; d--) {\n    var before = void 0,\n        after = void 0,\n        index = $pos.index(d);\n\n    if (d == $pos.depth) {\n      before = $pos.nodeBefore;\n      after = $pos.nodeAfter;\n    } else if (dir > 0) {\n      before = $pos.node(d + 1);\n      index++;\n      after = $pos.node(d).maybeChild(index);\n    } else {\n      before = $pos.node(d).maybeChild(index - 1);\n      after = $pos.node(d + 1);\n    }\n\n    if (before && !before.isTextblock && joinable(before, after) && $pos.node(d).canReplace(index, index + 1)) {\n      return pos;\n    }\n\n    if (d == 0) {\n      break;\n    }\n\n    pos = dir < 0 ? $pos.before(d) : $pos.after(d);\n  }\n} // :: (number, ?number) → this\n// Join the blocks around the given position. If depth is 2, their\n// last and first siblings are also joined, and so on.\n\n\nTransform.prototype.join = function (pos, depth) {\n  if (depth === void 0) depth = 1;\n  var step = new ReplaceStep(pos - depth, pos + depth, Slice.empty, true);\n  return this.step(step);\n}; // :: (Node, number, NodeType) → ?number\n// Try to find a point where a node of the given type can be inserted\n// near `pos`, by searching up the node hierarchy when `pos` itself\n// isn't a valid place but is at the start or end of a node. Return\n// null if no position was found.\n\n\nfunction insertPoint(doc, pos, nodeType) {\n  var $pos = doc.resolve(pos);\n\n  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType)) {\n    return pos;\n  }\n\n  if ($pos.parentOffset == 0) {\n    for (var d = $pos.depth - 1; d >= 0; d--) {\n      var index = $pos.index(d);\n\n      if ($pos.node(d).canReplaceWith(index, index, nodeType)) {\n        return $pos.before(d + 1);\n      }\n\n      if (index > 0) {\n        return null;\n      }\n    }\n  }\n\n  if ($pos.parentOffset == $pos.parent.content.size) {\n    for (var d$1 = $pos.depth - 1; d$1 >= 0; d$1--) {\n      var index$1 = $pos.indexAfter(d$1);\n\n      if ($pos.node(d$1).canReplaceWith(index$1, index$1, nodeType)) {\n        return $pos.after(d$1 + 1);\n      }\n\n      if (index$1 < $pos.node(d$1).childCount) {\n        return null;\n      }\n    }\n  }\n} // :: (Node, number, Slice) → ?number\n// Finds a position at or around the given position where the given\n// slice can be inserted. Will look at parent nodes' nearest boundary\n// and try there, even if the original position wasn't directly at the\n// start or end of that node. Returns null when no position was found.\n\n\nfunction dropPoint(doc, pos, slice) {\n  var $pos = doc.resolve(pos);\n\n  if (!slice.content.size) {\n    return pos;\n  }\n\n  var content = slice.content;\n\n  for (var i = 0; i < slice.openStart; i++) {\n    content = content.firstChild.content;\n  }\n\n  for (var pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {\n    for (var d = $pos.depth; d >= 0; d--) {\n      var bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;\n      var insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);\n      var parent = $pos.node(d),\n          fits = false;\n\n      if (pass == 1) {\n        fits = parent.canReplace(insertPos, insertPos, content);\n      } else {\n        var wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);\n        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);\n      }\n\n      if (fits) {\n        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction mapFragment(fragment, f, parent) {\n  var mapped = [];\n\n  for (var i = 0; i < fragment.childCount; i++) {\n    var child = fragment.child(i);\n\n    if (child.content.size) {\n      child = child.copy(mapFragment(child.content, f, child));\n    }\n\n    if (child.isInline) {\n      child = f(child, parent, i);\n    }\n\n    mapped.push(child);\n  }\n\n  return Fragment.fromArray(mapped);\n} // ::- Add a mark to all inline content between two positions.\n\n\nvar AddMarkStep = /*@__PURE__*/function (Step) {\n  function AddMarkStep(from, to, mark) {\n    Step.call(this); // :: number\n    // The start of the marked range.\n\n    this.from = from; // :: number\n    // The end of the marked range.\n\n    this.to = to; // :: Mark\n    // The mark to add.\n\n    this.mark = mark;\n  }\n\n  if (Step) AddMarkStep.__proto__ = Step;\n  AddMarkStep.prototype = Object.create(Step && Step.prototype);\n  AddMarkStep.prototype.constructor = AddMarkStep;\n\n  AddMarkStep.prototype.apply = function apply(doc) {\n    var this$1 = this;\n    var oldSlice = doc.slice(this.from, this.to),\n        $from = doc.resolve(this.from);\n    var parent = $from.node($from.sharedDepth(this.to));\n    var slice = new Slice(mapFragment(oldSlice.content, function (node, parent) {\n      if (!node.isAtom || !parent.type.allowsMarkType(this$1.mark.type)) {\n        return node;\n      }\n\n      return node.mark(this$1.mark.addToSet(node.marks));\n    }, parent), oldSlice.openStart, oldSlice.openEnd);\n    return StepResult.fromReplace(doc, this.from, this.to, slice);\n  };\n\n  AddMarkStep.prototype.invert = function invert() {\n    return new RemoveMarkStep(this.from, this.to, this.mark);\n  };\n\n  AddMarkStep.prototype.map = function map(mapping) {\n    var from = mapping.mapResult(this.from, 1),\n        to = mapping.mapResult(this.to, -1);\n\n    if (from.deleted && to.deleted || from.pos >= to.pos) {\n      return null;\n    }\n\n    return new AddMarkStep(from.pos, to.pos, this.mark);\n  };\n\n  AddMarkStep.prototype.merge = function merge(other) {\n    if (other instanceof AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) {\n      return new AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);\n    }\n  };\n\n  AddMarkStep.prototype.toJSON = function toJSON() {\n    return {\n      stepType: \"addMark\",\n      mark: this.mark.toJSON(),\n      from: this.from,\n      to: this.to\n    };\n  };\n\n  AddMarkStep.fromJSON = function fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\") {\n      throw new RangeError(\"Invalid input for AddMarkStep.fromJSON\");\n    }\n\n    return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));\n  };\n\n  return AddMarkStep;\n}(Step);\n\nStep.jsonID(\"addMark\", AddMarkStep); // ::- Remove a mark from all inline content between two positions.\n\nvar RemoveMarkStep = /*@__PURE__*/function (Step) {\n  function RemoveMarkStep(from, to, mark) {\n    Step.call(this); // :: number\n    // The start of the unmarked range.\n\n    this.from = from; // :: number\n    // The end of the unmarked range.\n\n    this.to = to; // :: Mark\n    // The mark to remove.\n\n    this.mark = mark;\n  }\n\n  if (Step) RemoveMarkStep.__proto__ = Step;\n  RemoveMarkStep.prototype = Object.create(Step && Step.prototype);\n  RemoveMarkStep.prototype.constructor = RemoveMarkStep;\n\n  RemoveMarkStep.prototype.apply = function apply(doc) {\n    var this$1 = this;\n    var oldSlice = doc.slice(this.from, this.to);\n    var slice = new Slice(mapFragment(oldSlice.content, function (node) {\n      return node.mark(this$1.mark.removeFromSet(node.marks));\n    }), oldSlice.openStart, oldSlice.openEnd);\n    return StepResult.fromReplace(doc, this.from, this.to, slice);\n  };\n\n  RemoveMarkStep.prototype.invert = function invert() {\n    return new AddMarkStep(this.from, this.to, this.mark);\n  };\n\n  RemoveMarkStep.prototype.map = function map(mapping) {\n    var from = mapping.mapResult(this.from, 1),\n        to = mapping.mapResult(this.to, -1);\n\n    if (from.deleted && to.deleted || from.pos >= to.pos) {\n      return null;\n    }\n\n    return new RemoveMarkStep(from.pos, to.pos, this.mark);\n  };\n\n  RemoveMarkStep.prototype.merge = function merge(other) {\n    if (other instanceof RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) {\n      return new RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);\n    }\n  };\n\n  RemoveMarkStep.prototype.toJSON = function toJSON() {\n    return {\n      stepType: \"removeMark\",\n      mark: this.mark.toJSON(),\n      from: this.from,\n      to: this.to\n    };\n  };\n\n  RemoveMarkStep.fromJSON = function fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\") {\n      throw new RangeError(\"Invalid input for RemoveMarkStep.fromJSON\");\n    }\n\n    return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));\n  };\n\n  return RemoveMarkStep;\n}(Step);\n\nStep.jsonID(\"removeMark\", RemoveMarkStep); // :: (number, number, Mark) → this\n// Add the given mark to the inline content between `from` and `to`.\n\nTransform.prototype.addMark = function (from, to, mark) {\n  var this$1 = this;\n  var removed = [],\n      added = [],\n      removing = null,\n      adding = null;\n  this.doc.nodesBetween(from, to, function (node, pos, parent) {\n    if (!node.isInline) {\n      return;\n    }\n\n    var marks = node.marks;\n\n    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {\n      var start = Math.max(pos, from),\n          end = Math.min(pos + node.nodeSize, to);\n      var newSet = mark.addToSet(marks);\n\n      for (var i = 0; i < marks.length; i++) {\n        if (!marks[i].isInSet(newSet)) {\n          if (removing && removing.to == start && removing.mark.eq(marks[i])) {\n            removing.to = end;\n          } else {\n            removed.push(removing = new RemoveMarkStep(start, end, marks[i]));\n          }\n        }\n      }\n\n      if (adding && adding.to == start) {\n        adding.to = end;\n      } else {\n        added.push(adding = new AddMarkStep(start, end, mark));\n      }\n    }\n  });\n  removed.forEach(function (s) {\n    return this$1.step(s);\n  });\n  added.forEach(function (s) {\n    return this$1.step(s);\n  });\n  return this;\n}; // :: (number, number, ?union<Mark, MarkType>) → this\n// Remove marks from inline nodes between `from` and `to`. When `mark`\n// is a single mark, remove precisely that mark. When it is a mark type,\n// remove all marks of that type. When it is null, remove all marks of\n// any type.\n\n\nTransform.prototype.removeMark = function (from, to, mark) {\n  var this$1 = this;\n  if (mark === void 0) mark = null;\n  var matched = [],\n      step = 0;\n  this.doc.nodesBetween(from, to, function (node, pos) {\n    if (!node.isInline) {\n      return;\n    }\n\n    step++;\n    var toRemove = null;\n\n    if (mark instanceof MarkType) {\n      var set = node.marks,\n          found;\n\n      while (found = mark.isInSet(set)) {\n        (toRemove || (toRemove = [])).push(found);\n        set = found.removeFromSet(set);\n      }\n    } else if (mark) {\n      if (mark.isInSet(node.marks)) {\n        toRemove = [mark];\n      }\n    } else {\n      toRemove = node.marks;\n    }\n\n    if (toRemove && toRemove.length) {\n      var end = Math.min(pos + node.nodeSize, to);\n\n      for (var i = 0; i < toRemove.length; i++) {\n        var style = toRemove[i],\n            found$1 = void 0;\n\n        for (var j = 0; j < matched.length; j++) {\n          var m = matched[j];\n\n          if (m.step == step - 1 && style.eq(matched[j].style)) {\n            found$1 = m;\n          }\n        }\n\n        if (found$1) {\n          found$1.to = end;\n          found$1.step = step;\n        } else {\n          matched.push({\n            style: style,\n            from: Math.max(pos, from),\n            to: end,\n            step: step\n          });\n        }\n      }\n    }\n  });\n  matched.forEach(function (m) {\n    return this$1.step(new RemoveMarkStep(m.from, m.to, m.style));\n  });\n  return this;\n}; // :: (number, NodeType, ?ContentMatch) → this\n// Removes all marks and nodes from the content of the node at `pos`\n// that don't match the given new parent node type. Accepts an\n// optional starting [content match](#model.ContentMatch) as third\n// argument.\n\n\nTransform.prototype.clearIncompatible = function (pos, parentType, match) {\n  if (match === void 0) match = parentType.contentMatch;\n  var node = this.doc.nodeAt(pos);\n  var delSteps = [],\n      cur = pos + 1;\n\n  for (var i = 0; i < node.childCount; i++) {\n    var child = node.child(i),\n        end = cur + child.nodeSize;\n    var allowed = match.matchType(child.type, child.attrs);\n\n    if (!allowed) {\n      delSteps.push(new ReplaceStep(cur, end, Slice.empty));\n    } else {\n      match = allowed;\n\n      for (var j = 0; j < child.marks.length; j++) {\n        if (!parentType.allowsMarkType(child.marks[j].type)) {\n          this.step(new RemoveMarkStep(cur, end, child.marks[j]));\n        }\n      }\n    }\n\n    cur = end;\n  }\n\n  if (!match.validEnd) {\n    var fill = match.fillBefore(Fragment.empty, true);\n    this.replace(cur, cur, new Slice(fill, 0, 0));\n  }\n\n  for (var i$1 = delSteps.length - 1; i$1 >= 0; i$1--) {\n    this.step(delSteps[i$1]);\n  }\n\n  return this;\n}; // :: (Node, number, ?number, ?Slice) → ?Step\n// ‘Fit’ a slice into a given position in the document, producing a\n// [step](#transform.Step) that inserts it. Will return null if\n// there's no meaningful way to insert the slice here, or inserting it\n// would be a no-op (an empty slice over an empty range).\n\n\nfunction replaceStep(doc, from, to, slice) {\n  if (to === void 0) to = from;\n  if (slice === void 0) slice = Slice.empty;\n\n  if (from == to && !slice.size) {\n    return null;\n  }\n\n  var $from = doc.resolve(from),\n      $to = doc.resolve(to); // Optimization -- avoid work if it's obvious that it's not needed.\n\n  if (fitsTrivially($from, $to, slice)) {\n    return new ReplaceStep(from, to, slice);\n  }\n\n  return new Fitter($from, $to, slice).fit();\n} // :: (number, ?number, ?Slice) → this\n// Replace the part of the document between `from` and `to` with the\n// given `slice`.\n\n\nTransform.prototype.replace = function (from, to, slice) {\n  if (to === void 0) to = from;\n  if (slice === void 0) slice = Slice.empty;\n  var step = replaceStep(this.doc, from, to, slice);\n\n  if (step) {\n    this.step(step);\n  }\n\n  return this;\n}; // :: (number, number, union<Fragment, Node, [Node]>) → this\n// Replace the given range with the given content, which may be a\n// fragment, node, or array of nodes.\n\n\nTransform.prototype.replaceWith = function (from, to, content) {\n  return this.replace(from, to, new Slice(Fragment.from(content), 0, 0));\n}; // :: (number, number) → this\n// Delete the content between the given positions.\n\n\nTransform.prototype.delete = function (from, to) {\n  return this.replace(from, to, Slice.empty);\n}; // :: (number, union<Fragment, Node, [Node]>) → this\n// Insert the given content at the given position.\n\n\nTransform.prototype.insert = function (pos, content) {\n  return this.replaceWith(pos, pos, content);\n};\n\nfunction fitsTrivially($from, $to, slice) {\n  return !slice.openStart && !slice.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice.content);\n} // Algorithm for 'placing' the elements of a slice into a gap:\n//\n// We consider the content of each node that is open to the left to be\n// independently placeable. I.e. in <p(\"foo\"), p(\"bar\")>, when the\n// paragraph on the left is open, \"foo\" can be placed (somewhere on\n// the left side of the replacement gap) independently from p(\"bar\").\n//\n// This class tracks the state of the placement progress in the\n// following properties:\n//\n//  - `frontier` holds a stack of `{type, match}` objects that\n//    represent the open side of the replacement. It starts at\n//    `$from`, then moves forward as content is placed, and is finally\n//    reconciled with `$to`.\n//\n//  - `unplaced` is a slice that represents the content that hasn't\n//    been placed yet.\n//\n//  - `placed` is a fragment of placed content. Its open-start value\n//    is implicit in `$from`, and its open-end value in `frontier`.\n\n\nvar Fitter = function Fitter($from, $to, slice) {\n  this.$to = $to;\n  this.$from = $from;\n  this.unplaced = slice;\n  this.frontier = [];\n\n  for (var i = 0; i <= $from.depth; i++) {\n    var node = $from.node(i);\n    this.frontier.push({\n      type: node.type,\n      match: node.contentMatchAt($from.indexAfter(i))\n    });\n  }\n\n  this.placed = Fragment.empty;\n\n  for (var i$1 = $from.depth; i$1 > 0; i$1--) {\n    this.placed = Fragment.from($from.node(i$1).copy(this.placed));\n  }\n};\n\nvar prototypeAccessors$1 = {\n  depth: {\n    configurable: true\n  }\n};\n\nprototypeAccessors$1.depth.get = function () {\n  return this.frontier.length - 1;\n};\n\nFitter.prototype.fit = function fit() {\n  // As long as there's unplaced content, try to place some of it.\n  // If that fails, either increase the open score of the unplaced\n  // slice, or drop nodes from it, and then try again.\n  while (this.unplaced.size) {\n    var fit = this.findFittable();\n\n    if (fit) {\n      this.placeNodes(fit);\n    } else {\n      this.openMore() || this.dropNode();\n    }\n  } // When there's inline content directly after the frontier _and_\n  // directly after `this.$to`, we must generate a `ReplaceAround`\n  // step that pulls that content into the node after the frontier.\n  // That means the fitting must be done to the end of the textblock\n  // node after `this.$to`, not `this.$to` itself.\n\n\n  var moveInline = this.mustMoveInline(),\n      placedSize = this.placed.size - this.depth - this.$from.depth;\n  var $from = this.$from,\n      $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));\n\n  if (!$to) {\n    return null;\n  } // If closing to `$to` succeeded, create a step\n\n\n  var content = this.placed,\n      openStart = $from.depth,\n      openEnd = $to.depth;\n\n  while (openStart && openEnd && content.childCount == 1) {\n    // Normalize by dropping open parent nodes\n    content = content.firstChild.content;\n    openStart--;\n    openEnd--;\n  }\n\n  var slice = new Slice(content, openStart, openEnd);\n\n  if (moveInline > -1) {\n    return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize);\n  }\n\n  if (slice.size || $from.pos != this.$to.pos) // Don't generate no-op steps\n    {\n      return new ReplaceStep($from.pos, $to.pos, slice);\n    }\n}; // Find a position on the start spine of `this.unplaced` that has\n// content that can be moved somewhere on the frontier. Returns two\n// depths, one for the slice and one for the frontier.\n\n\nFitter.prototype.findFittable = function findFittable() {\n  // Only try wrapping nodes (pass 2) after finding a place without\n  // wrapping failed.\n  for (var pass = 1; pass <= 2; pass++) {\n    for (var sliceDepth = this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {\n      var fragment = void 0,\n          parent = void 0;\n\n      if (sliceDepth) {\n        parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;\n        fragment = parent.content;\n      } else {\n        fragment = this.unplaced.content;\n      }\n\n      var first = fragment.firstChild;\n\n      for (var frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {\n        var ref = this.frontier[frontierDepth];\n        var type = ref.type;\n        var match = ref.match;\n        var wrap = void 0,\n            inject = void 0; // In pass 1, if the next node matches, or there is no next\n        // node but the parents look compatible, we've found a\n        // place.\n\n        if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(Fragment.from(first), false)) : type.compatibleContent(parent.type))) {\n          return {\n            sliceDepth: sliceDepth,\n            frontierDepth: frontierDepth,\n            parent: parent,\n            inject: inject\n          };\n        } // In pass 2, look for a set of wrapping nodes that make\n        // `first` fit here.\n        else if (pass == 2 && first && (wrap = match.findWrapping(first.type))) {\n          return {\n            sliceDepth: sliceDepth,\n            frontierDepth: frontierDepth,\n            parent: parent,\n            wrap: wrap\n          };\n        } // Don't continue looking further up if the parent node\n        // would fit here.\n\n\n        if (parent && match.matchType(parent.type)) {\n          break;\n        }\n      }\n    }\n  }\n};\n\nFitter.prototype.openMore = function openMore() {\n  var ref = this.unplaced;\n  var content = ref.content;\n  var openStart = ref.openStart;\n  var openEnd = ref.openEnd;\n  var inner = contentAt(content, openStart);\n\n  if (!inner.childCount || inner.firstChild.isLeaf) {\n    return false;\n  }\n\n  this.unplaced = new Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));\n  return true;\n};\n\nFitter.prototype.dropNode = function dropNode() {\n  var ref = this.unplaced;\n  var content = ref.content;\n  var openStart = ref.openStart;\n  var openEnd = ref.openEnd;\n  var inner = contentAt(content, openStart);\n\n  if (inner.childCount <= 1 && openStart > 0) {\n    var openAtEnd = content.size - openStart <= openStart + inner.size;\n    this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);\n  } else {\n    this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);\n  }\n}; // : ({sliceDepth: number, frontierDepth: number, parent: ?Node, wrap: ?[NodeType], inject: ?Fragment})\n// Move content from the unplaced slice at `sliceDepth` to the\n// frontier node at `frontierDepth`. Close that frontier node when\n// applicable.\n\n\nFitter.prototype.placeNodes = function placeNodes(ref) {\n  var sliceDepth = ref.sliceDepth;\n  var frontierDepth = ref.frontierDepth;\n  var parent = ref.parent;\n  var inject = ref.inject;\n  var wrap = ref.wrap;\n\n  while (this.depth > frontierDepth) {\n    this.closeFrontierNode();\n  }\n\n  if (wrap) {\n    for (var i = 0; i < wrap.length; i++) {\n      this.openFrontierNode(wrap[i]);\n    }\n  }\n\n  var slice = this.unplaced,\n      fragment = parent ? parent.content : slice.content;\n  var openStart = slice.openStart - sliceDepth;\n  var taken = 0,\n      add = [];\n  var ref$1 = this.frontier[frontierDepth];\n  var match = ref$1.match;\n  var type = ref$1.type;\n\n  if (inject) {\n    for (var i$1 = 0; i$1 < inject.childCount; i$1++) {\n      add.push(inject.child(i$1));\n    }\n\n    match = match.matchFragment(inject);\n  } // Computes the amount of (end) open nodes at the end of the\n  // fragment. When 0, the parent is open, but no more. When\n  // negative, nothing is open.\n\n\n  var openEndCount = fragment.size + sliceDepth - (slice.content.size - slice.openEnd); // Scan over the fragment, fitting as many child nodes as\n  // possible.\n\n  while (taken < fragment.childCount) {\n    var next = fragment.child(taken),\n        matches = match.matchType(next.type);\n\n    if (!matches) {\n      break;\n    }\n\n    taken++;\n\n    if (taken > 1 || openStart == 0 || next.content.size) {\n      // Drop empty open nodes\n      match = matches;\n      add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));\n    }\n  }\n\n  var toEnd = taken == fragment.childCount;\n\n  if (!toEnd) {\n    openEndCount = -1;\n  }\n\n  this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add));\n  this.frontier[frontierDepth].match = match; // If the parent types match, and the entire node was moved, and\n  // it's not open, close this frontier node right away.\n\n  if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1) {\n    this.closeFrontierNode();\n  } // Add new frontier nodes for any open nodes at the end.\n\n\n  for (var i$2 = 0, cur = fragment; i$2 < openEndCount; i$2++) {\n    var node = cur.lastChild;\n    this.frontier.push({\n      type: node.type,\n      match: node.contentMatchAt(node.childCount)\n    });\n    cur = node.content;\n  } // Update `this.unplaced`. Drop the entire node from which we\n  // placed it we got to its end, otherwise just drop the placed\n  // nodes.\n\n\n  this.unplaced = !toEnd ? new Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1);\n};\n\nFitter.prototype.mustMoveInline = function mustMoveInline() {\n  if (!this.$to.parent.isTextblock || this.$to.end() == this.$to.pos) {\n    return -1;\n  }\n\n  var top = this.frontier[this.depth],\n      level;\n\n  if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth) {\n    return -1;\n  }\n\n  var ref = this.$to;\n  var depth = ref.depth;\n  var after = this.$to.after(depth);\n\n  while (depth > 1 && after == this.$to.end(--depth)) {\n    ++after;\n  }\n\n  return after;\n};\n\nFitter.prototype.findCloseLevel = function findCloseLevel($to) {\n  scan: for (var i = Math.min(this.depth, $to.depth); i >= 0; i--) {\n    var ref = this.frontier[i];\n    var match = ref.match;\n    var type = ref.type;\n    var dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));\n    var fit = contentAfterFits($to, i, type, match, dropInner);\n\n    if (!fit) {\n      continue;\n    }\n\n    for (var d = i - 1; d >= 0; d--) {\n      var ref$1 = this.frontier[d];\n      var match$1 = ref$1.match;\n      var type$1 = ref$1.type;\n      var matches = contentAfterFits($to, d, type$1, match$1, true);\n\n      if (!matches || matches.childCount) {\n        continue scan;\n      }\n    }\n\n    return {\n      depth: i,\n      fit: fit,\n      move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to\n    };\n  }\n};\n\nFitter.prototype.close = function close($to) {\n  var close = this.findCloseLevel($to);\n\n  if (!close) {\n    return null;\n  }\n\n  while (this.depth > close.depth) {\n    this.closeFrontierNode();\n  }\n\n  if (close.fit.childCount) {\n    this.placed = addToFragment(this.placed, close.depth, close.fit);\n  }\n\n  $to = close.move;\n\n  for (var d = close.depth + 1; d <= $to.depth; d++) {\n    var node = $to.node(d),\n        add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));\n    this.openFrontierNode(node.type, node.attrs, add);\n  }\n\n  return $to;\n};\n\nFitter.prototype.openFrontierNode = function openFrontierNode(type, attrs, content) {\n  var top = this.frontier[this.depth];\n  top.match = top.match.matchType(type);\n  this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)));\n  this.frontier.push({\n    type: type,\n    match: type.contentMatch\n  });\n};\n\nFitter.prototype.closeFrontierNode = function closeFrontierNode() {\n  var open = this.frontier.pop();\n  var add = open.match.fillBefore(Fragment.empty, true);\n\n  if (add.childCount) {\n    this.placed = addToFragment(this.placed, this.frontier.length, add);\n  }\n};\n\nObject.defineProperties(Fitter.prototype, prototypeAccessors$1);\n\nfunction dropFromFragment(fragment, depth, count) {\n  if (depth == 0) {\n    return fragment.cutByIndex(count);\n  }\n\n  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));\n}\n\nfunction addToFragment(fragment, depth, content) {\n  if (depth == 0) {\n    return fragment.append(content);\n  }\n\n  return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));\n}\n\nfunction contentAt(fragment, depth) {\n  for (var i = 0; i < depth; i++) {\n    fragment = fragment.firstChild.content;\n  }\n\n  return fragment;\n}\n\nfunction closeNodeStart(node, openStart, openEnd) {\n  if (openStart <= 0) {\n    return node;\n  }\n\n  var frag = node.content;\n\n  if (openStart > 1) {\n    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));\n  }\n\n  if (openStart > 0) {\n    frag = node.type.contentMatch.fillBefore(frag).append(frag);\n\n    if (openEnd <= 0) {\n      frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true));\n    }\n  }\n\n  return node.copy(frag);\n}\n\nfunction contentAfterFits($to, depth, type, match, open) {\n  var node = $to.node(depth),\n      index = open ? $to.indexAfter(depth) : $to.index(depth);\n\n  if (index == node.childCount && !type.compatibleContent(node.type)) {\n    return null;\n  }\n\n  var fit = match.fillBefore(node.content, true, index);\n  return fit && !invalidMarks(type, node.content, index) ? fit : null;\n}\n\nfunction invalidMarks(type, fragment, start) {\n  for (var i = start; i < fragment.childCount; i++) {\n    if (!type.allowsMarks(fragment.child(i).marks)) {\n      return true;\n    }\n  }\n\n  return false;\n} // :: (number, number, Slice) → this\n// Replace a range of the document with a given slice, using `from`,\n// `to`, and the slice's [`openStart`](#model.Slice.openStart) property\n// as hints, rather than fixed start and end points. This method may\n// grow the replaced area or close open nodes in the slice in order to\n// get a fit that is more in line with WYSIWYG expectations, by\n// dropping fully covered parent nodes of the replaced region when\n// they are marked [non-defining](#model.NodeSpec.defining), or\n// including an open parent node from the slice that _is_ marked as\n// [defining](#model.NodeSpec.defining).\n//\n// This is the method, for example, to handle paste. The similar\n// [`replace`](#transform.Transform.replace) method is a more\n// primitive tool which will _not_ move the start and end of its given\n// range, and is useful in situations where you need more precise\n// control over what happens.\n\n\nTransform.prototype.replaceRange = function (from, to, slice) {\n  if (!slice.size) {\n    return this.deleteRange(from, to);\n  }\n\n  var $from = this.doc.resolve(from),\n      $to = this.doc.resolve(to);\n\n  if (fitsTrivially($from, $to, slice)) {\n    return this.step(new ReplaceStep(from, to, slice));\n  }\n\n  var targetDepths = coveredDepths($from, this.doc.resolve(to)); // Can't replace the whole document, so remove 0 if it's present\n\n  if (targetDepths[targetDepths.length - 1] == 0) {\n    targetDepths.pop();\n  } // Negative numbers represent not expansion over the whole node at\n  // that depth, but replacing from $from.before(-D) to $to.pos.\n\n\n  var preferredTarget = -($from.depth + 1);\n  targetDepths.unshift(preferredTarget); // This loop picks a preferred target depth, if one of the covering\n  // depths is not outside of a defining node, and adds negative\n  // depths for any depth that has $from at its start and does not\n  // cross a defining node.\n\n  for (var d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {\n    var spec = $from.node(d).type.spec;\n\n    if (spec.defining || spec.isolating) {\n      break;\n    }\n\n    if (targetDepths.indexOf(d) > -1) {\n      preferredTarget = d;\n    } else if ($from.before(d) == pos) {\n      targetDepths.splice(1, 0, -d);\n    }\n  } // Try to fit each possible depth of the slice into each possible\n  // target depth, starting with the preferred depths.\n\n\n  var preferredTargetIndex = targetDepths.indexOf(preferredTarget);\n  var leftNodes = [],\n      preferredDepth = slice.openStart;\n\n  for (var content = slice.content, i = 0;; i++) {\n    var node = content.firstChild;\n    leftNodes.push(node);\n\n    if (i == slice.openStart) {\n      break;\n    }\n\n    content = node.content;\n  } // Back up if the node directly above openStart, or the node above\n  // that separated only by a non-defining textblock node, is defining.\n\n\n  if (preferredDepth > 0 && leftNodes[preferredDepth - 1].type.spec.defining && $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 1].type) {\n    preferredDepth -= 1;\n  } else if (preferredDepth >= 2 && leftNodes[preferredDepth - 1].isTextblock && leftNodes[preferredDepth - 2].type.spec.defining && $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 2].type) {\n    preferredDepth -= 2;\n  }\n\n  for (var j = slice.openStart; j >= 0; j--) {\n    var openDepth = (j + preferredDepth + 1) % (slice.openStart + 1);\n    var insert = leftNodes[openDepth];\n\n    if (!insert) {\n      continue;\n    }\n\n    for (var i$1 = 0; i$1 < targetDepths.length; i$1++) {\n      // Loop over possible expansion levels, starting with the\n      // preferred one\n      var targetDepth = targetDepths[(i$1 + preferredTargetIndex) % targetDepths.length],\n          expand = true;\n\n      if (targetDepth < 0) {\n        expand = false;\n        targetDepth = -targetDepth;\n      }\n\n      var parent = $from.node(targetDepth - 1),\n          index = $from.index(targetDepth - 1);\n\n      if (parent.canReplaceWith(index, index, insert.type, insert.marks)) {\n        return this.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new Slice(closeFragment(slice.content, 0, slice.openStart, openDepth), openDepth, slice.openEnd));\n      }\n    }\n  }\n\n  var startSteps = this.steps.length;\n\n  for (var i$2 = targetDepths.length - 1; i$2 >= 0; i$2--) {\n    this.replace(from, to, slice);\n\n    if (this.steps.length > startSteps) {\n      break;\n    }\n\n    var depth = targetDepths[i$2];\n\n    if (depth < 0) {\n      continue;\n    }\n\n    from = $from.before(depth);\n    to = $to.after(depth);\n  }\n\n  return this;\n};\n\nfunction closeFragment(fragment, depth, oldOpen, newOpen, parent) {\n  if (depth < oldOpen) {\n    var first = fragment.firstChild;\n    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));\n  }\n\n  if (depth > newOpen) {\n    var match = parent.contentMatchAt(0);\n    var start = match.fillBefore(fragment).append(fragment);\n    fragment = start.append(match.matchFragment(start).fillBefore(Fragment.empty, true));\n  }\n\n  return fragment;\n} // :: (number, number, Node) → this\n// Replace the given range with a node, but use `from` and `to` as\n// hints, rather than precise positions. When from and to are the same\n// and are at the start or end of a parent node in which the given\n// node doesn't fit, this method may _move_ them out towards a parent\n// that does allow the given node to be placed. When the given range\n// completely covers a parent node, this method may completely replace\n// that parent node.\n\n\nTransform.prototype.replaceRangeWith = function (from, to, node) {\n  if (!node.isInline && from == to && this.doc.resolve(from).parent.content.size) {\n    var point = insertPoint(this.doc, from, node.type);\n\n    if (point != null) {\n      from = to = point;\n    }\n  }\n\n  return this.replaceRange(from, to, new Slice(Fragment.from(node), 0, 0));\n}; // :: (number, number) → this\n// Delete the given range, expanding it to cover fully covered\n// parent nodes until a valid replace is found.\n\n\nTransform.prototype.deleteRange = function (from, to) {\n  var $from = this.doc.resolve(from),\n      $to = this.doc.resolve(to);\n  var covered = coveredDepths($from, $to);\n\n  for (var i = 0; i < covered.length; i++) {\n    var depth = covered[i],\n        last = i == covered.length - 1;\n\n    if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd) {\n      return this.delete($from.start(depth), $to.end(depth));\n    }\n\n    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1)))) {\n      return this.delete($from.before(depth), $to.after(depth));\n    }\n  }\n\n  for (var d = 1; d <= $from.depth && d <= $to.depth; d++) {\n    if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d) {\n      return this.delete($from.before(d), to);\n    }\n  }\n\n  return this.delete(from, to);\n}; // : (ResolvedPos, ResolvedPos) → [number]\n// Returns an array of all depths for which $from - $to spans the\n// whole content of the nodes at that depth.\n\n\nfunction coveredDepths($from, $to) {\n  var result = [],\n      minDepth = Math.min($from.depth, $to.depth);\n\n  for (var d = minDepth; d >= 0; d--) {\n    var start = $from.start(d);\n\n    if (start < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating) {\n      break;\n    }\n\n    if (start == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start - 1) {\n      result.push(d);\n    }\n  }\n\n  return result;\n}\n\nexport { AddMarkStep, MapResult, Mapping, RemoveMarkStep, ReplaceAroundStep, ReplaceStep, Step, StepMap, StepResult, Transform, TransformError, canJoin, canSplit, dropPoint, findWrapping, insertPoint, joinPoint, liftTarget, replaceStep }; //# sourceMappingURL=index.es.js.map","map":null,"metadata":{},"sourceType":"module"}