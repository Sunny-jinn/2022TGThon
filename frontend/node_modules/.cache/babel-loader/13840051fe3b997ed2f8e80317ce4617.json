{"ast":null,"code":"import RopeSequence from 'rope-sequence';\nimport { Mapping } from 'prosemirror-transform';\nimport { PluginKey, Plugin } from 'prosemirror-state'; // ProseMirror's history isn't simply a way to roll back to a previous\n// state, because ProseMirror supports applying changes without adding\n// them to the history (for example during collaboration).\n//\n// To this end, each 'Branch' (one for the undo history and one for\n// the redo history) keeps an array of 'Items', which can optionally\n// hold a step (an actual undoable change), and always hold a position\n// map (which is needed to move changes below them to apply to the\n// current document).\n//\n// An item that has both a step and a selection bookmark is the start\n// of an 'event' — a group of changes that will be undone or redone at\n// once. (It stores only the bookmark, since that way we don't have to\n// provide a document until the selection is actually applied, which\n// is useful when compressing.)\n// Used to schedule history compression\n\nconst max_empty_items = 500;\n\nclass Branch {\n  constructor(items, eventCount) {\n    this.items = items;\n    this.eventCount = eventCount;\n  } // Pop the latest event off the branch's history and apply it\n  // to a document transform.\n\n\n  popEvent(state, preserveItems) {\n    if (this.eventCount == 0) return null;\n    let end = this.items.length;\n\n    for (;; end--) {\n      let next = this.items.get(end - 1);\n\n      if (next.selection) {\n        --end;\n        break;\n      }\n    }\n\n    let remap, mapFrom;\n\n    if (preserveItems) {\n      remap = this.remapping(end, this.items.length);\n      mapFrom = remap.maps.length;\n    }\n\n    let transform = state.tr;\n    let selection, remaining;\n    let addAfter = [],\n        addBefore = [];\n    this.items.forEach((item, i) => {\n      if (!item.step) {\n        if (!remap) {\n          remap = this.remapping(end, i + 1);\n          mapFrom = remap.maps.length;\n        }\n\n        mapFrom--;\n        addBefore.push(item);\n        return;\n      }\n\n      if (remap) {\n        addBefore.push(new Item(item.map));\n        let step = item.step.map(remap.slice(mapFrom)),\n            map;\n\n        if (step && transform.maybeStep(step).doc) {\n          map = transform.mapping.maps[transform.mapping.maps.length - 1];\n          addAfter.push(new Item(map, undefined, undefined, addAfter.length + addBefore.length));\n        }\n\n        mapFrom--;\n        if (map) remap.appendMap(map, mapFrom);\n      } else {\n        transform.maybeStep(item.step);\n      }\n\n      if (item.selection) {\n        selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;\n        remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);\n        return false;\n      }\n    }, this.items.length, 0);\n    return {\n      remaining: remaining,\n      transform,\n      selection: selection\n    };\n  } // Create a new branch with the given transform added.\n\n\n  addTransform(transform, selection, histOptions, preserveItems) {\n    let newItems = [],\n        eventCount = this.eventCount;\n    let oldItems = this.items,\n        lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;\n\n    for (let i = 0; i < transform.steps.length; i++) {\n      let step = transform.steps[i].invert(transform.docs[i]);\n      let item = new Item(transform.mapping.maps[i], step, selection),\n          merged;\n\n      if (merged = lastItem && lastItem.merge(item)) {\n        item = merged;\n        if (i) newItems.pop();else oldItems = oldItems.slice(0, oldItems.length - 1);\n      }\n\n      newItems.push(item);\n\n      if (selection) {\n        eventCount++;\n        selection = undefined;\n      }\n\n      if (!preserveItems) lastItem = item;\n    }\n\n    let overflow = eventCount - histOptions.depth;\n\n    if (overflow > DEPTH_OVERFLOW) {\n      oldItems = cutOffEvents(oldItems, overflow);\n      eventCount -= overflow;\n    }\n\n    return new Branch(oldItems.append(newItems), eventCount);\n  }\n\n  remapping(from, to) {\n    let maps = new Mapping();\n    this.items.forEach((item, i) => {\n      let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from ? maps.maps.length - item.mirrorOffset : undefined;\n      maps.appendMap(item.map, mirrorPos);\n    }, from, to);\n    return maps;\n  }\n\n  addMaps(array) {\n    if (this.eventCount == 0) return this;\n    return new Branch(this.items.append(array.map(map => new Item(map))), this.eventCount);\n  } // When the collab module receives remote changes, the history has\n  // to know about those, so that it can adjust the steps that were\n  // rebased on top of the remote changes, and include the position\n  // maps for the remote changes in its array of items.\n\n\n  rebased(rebasedTransform, rebasedCount) {\n    if (!this.eventCount) return this;\n    let rebasedItems = [],\n        start = Math.max(0, this.items.length - rebasedCount);\n    let mapping = rebasedTransform.mapping;\n    let newUntil = rebasedTransform.steps.length;\n    let eventCount = this.eventCount;\n    this.items.forEach(item => {\n      if (item.selection) eventCount--;\n    }, start);\n    let iRebased = rebasedCount;\n    this.items.forEach(item => {\n      let pos = mapping.getMirror(--iRebased);\n      if (pos == null) return;\n      newUntil = Math.min(newUntil, pos);\n      let map = mapping.maps[pos];\n\n      if (item.step) {\n        let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);\n        let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));\n        if (selection) eventCount++;\n        rebasedItems.push(new Item(map, step, selection));\n      } else {\n        rebasedItems.push(new Item(map));\n      }\n    }, start);\n    let newMaps = [];\n\n    for (let i = rebasedCount; i < newUntil; i++) newMaps.push(new Item(mapping.maps[i]));\n\n    let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);\n    let branch = new Branch(items, eventCount);\n    if (branch.emptyItemCount() > max_empty_items) branch = branch.compress(this.items.length - rebasedItems.length);\n    return branch;\n  }\n\n  emptyItemCount() {\n    let count = 0;\n    this.items.forEach(item => {\n      if (!item.step) count++;\n    });\n    return count;\n  } // Compressing a branch means rewriting it to push the air (map-only\n  // items) out. During collaboration, these naturally accumulate\n  // because each remote change adds one. The `upto` argument is used\n  // to ensure that only the items below a given level are compressed,\n  // because `rebased` relies on a clean, untouched set of items in\n  // order to associate old items with rebased steps.\n\n\n  compress() {\n    let upto = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.items.length;\n    let remap = this.remapping(0, upto),\n        mapFrom = remap.maps.length;\n    let items = [],\n        events = 0;\n    this.items.forEach((item, i) => {\n      if (i >= upto) {\n        items.push(item);\n        if (item.selection) events++;\n      } else if (item.step) {\n        let step = item.step.map(remap.slice(mapFrom)),\n            map = step && step.getMap();\n        mapFrom--;\n        if (map) remap.appendMap(map, mapFrom);\n\n        if (step) {\n          let selection = item.selection && item.selection.map(remap.slice(mapFrom));\n          if (selection) events++;\n          let newItem = new Item(map.invert(), step, selection),\n              merged,\n              last = items.length - 1;\n          if (merged = items.length && items[last].merge(newItem)) items[last] = merged;else items.push(newItem);\n        }\n      } else if (item.map) {\n        mapFrom--;\n      }\n    }, this.items.length, 0);\n    return new Branch(RopeSequence.from(items.reverse()), events);\n  }\n\n}\n\nBranch.empty = new Branch(RopeSequence.empty, 0);\n\nfunction cutOffEvents(items, n) {\n  let cutPoint;\n  items.forEach((item, i) => {\n    if (item.selection && n-- == 0) {\n      cutPoint = i;\n      return false;\n    }\n  });\n  return items.slice(cutPoint);\n}\n\nclass Item {\n  constructor( // The (forward) step map for this item.\n  map, // The inverted step\n  step, // If this is non-null, this item is the start of a group, and\n  // this selection is the starting selection for the group (the one\n  // that was active before the first step was applied)\n  selection, // If this item is the inverse of a previous mapping on the stack,\n  // this points at the inverse's offset\n  mirrorOffset) {\n    this.map = map;\n    this.step = step;\n    this.selection = selection;\n    this.mirrorOffset = mirrorOffset;\n  }\n\n  merge(other) {\n    if (this.step && other.step && !other.selection) {\n      let step = other.step.merge(this.step);\n      if (step) return new Item(step.getMap().invert(), step, this.selection);\n    }\n  }\n\n} // The value of the state field that tracks undo/redo history for that\n// state. Will be stored in the plugin state when the history plugin\n// is active.\n\n\nclass HistoryState {\n  constructor(done, undone, prevRanges, prevTime) {\n    this.done = done;\n    this.undone = undone;\n    this.prevRanges = prevRanges;\n    this.prevTime = prevTime;\n  }\n\n}\n\nconst DEPTH_OVERFLOW = 20; // Record a transformation in undo history.\n\nfunction applyTransaction(history, state, tr, options) {\n  let historyTr = tr.getMeta(historyKey),\n      rebased;\n  if (historyTr) return historyTr.historyState;\n  if (tr.getMeta(closeHistoryKey)) history = new HistoryState(history.done, history.undone, null, 0);\n  let appended = tr.getMeta(\"appendedTransaction\");\n\n  if (tr.steps.length == 0) {\n    return history;\n  } else if (appended && appended.getMeta(historyKey)) {\n    if (appended.getMeta(historyKey).redo) return new HistoryState(history.done.addTransform(tr, undefined, options, mustPreserveItems(state)), history.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history.prevTime);else return new HistoryState(history.done, history.undone.addTransform(tr, undefined, options, mustPreserveItems(state)), null, history.prevTime);\n  } else if (tr.getMeta(\"addToHistory\") !== false && !(appended && appended.getMeta(\"addToHistory\") === false)) {\n    // Group transforms that occur in quick succession into one event.\n    let newGroup = history.prevTime == 0 || !appended && (history.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history.prevRanges));\n    let prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1]);\n    return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : undefined, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time);\n  } else if (rebased = tr.getMeta(\"rebased\")) {\n    // Used by the collab module to tell the history that some of its\n    // content has been rebased.\n    return new HistoryState(history.done.rebased(tr, rebased), history.undone.rebased(tr, rebased), mapRanges(history.prevRanges, tr.mapping), history.prevTime);\n  } else {\n    return new HistoryState(history.done.addMaps(tr.mapping.maps), history.undone.addMaps(tr.mapping.maps), mapRanges(history.prevRanges, tr.mapping), history.prevTime);\n  }\n}\n\nfunction isAdjacentTo(transform, prevRanges) {\n  if (!prevRanges) return false;\n  if (!transform.docChanged) return true;\n  let adjacent = false;\n  transform.mapping.maps[0].forEach((start, end) => {\n    for (let i = 0; i < prevRanges.length; i += 2) if (start <= prevRanges[i + 1] && end >= prevRanges[i]) adjacent = true;\n  });\n  return adjacent;\n}\n\nfunction rangesFor(map) {\n  let result = [];\n  map.forEach((_from, _to, from, to) => result.push(from, to));\n  return result;\n}\n\nfunction mapRanges(ranges, mapping) {\n  if (!ranges) return null;\n  let result = [];\n\n  for (let i = 0; i < ranges.length; i += 2) {\n    let from = mapping.map(ranges[i], 1),\n        to = mapping.map(ranges[i + 1], -1);\n    if (from <= to) result.push(from, to);\n  }\n\n  return result;\n} // Apply the latest event from one branch to the document and shift the event\n// onto the other branch.\n\n\nfunction histTransaction(history, state, dispatch, redo) {\n  let preserveItems = mustPreserveItems(state);\n  let histOptions = historyKey.get(state).spec.config;\n  let pop = (redo ? history.undone : history.done).popEvent(state, preserveItems);\n  if (!pop) return;\n  let selection = pop.selection.resolve(pop.transform.doc);\n  let added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);\n  let newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0);\n  dispatch(pop.transform.setSelection(selection).setMeta(historyKey, {\n    redo,\n    historyState: newHist\n  }).scrollIntoView());\n}\n\nlet cachedPreserveItems = false,\n    cachedPreserveItemsPlugins = null; // Check whether any plugin in the given state has a\n// `historyPreserveItems` property in its spec, in which case we must\n// preserve steps exactly as they came in, so that they can be\n// rebased.\n\nfunction mustPreserveItems(state) {\n  let plugins = state.plugins;\n\n  if (cachedPreserveItemsPlugins != plugins) {\n    cachedPreserveItems = false;\n    cachedPreserveItemsPlugins = plugins;\n\n    for (let i = 0; i < plugins.length; i++) if (plugins[i].spec.historyPreserveItems) {\n      cachedPreserveItems = true;\n      break;\n    }\n  }\n\n  return cachedPreserveItems;\n}\n/**\nSet a flag on the given transaction that will prevent further steps\nfrom being appended to an existing history event (so that they\nrequire a separate undo command to undo).\n*/\n\n\nfunction closeHistory(tr) {\n  return tr.setMeta(closeHistoryKey, true);\n}\n\nconst historyKey = new PluginKey(\"history\");\nconst closeHistoryKey = new PluginKey(\"closeHistory\");\n/**\nReturns a plugin that enables the undo history for an editor. The\nplugin will track undo and redo stacks, which can be used with the\n[`undo`](https://prosemirror.net/docs/ref/#history.undo) and [`redo`](https://prosemirror.net/docs/ref/#history.redo) commands.\n\nYou can set an `\"addToHistory\"` [metadata\nproperty](https://prosemirror.net/docs/ref/#state.Transaction.setMeta) of `false` on a transaction\nto prevent it from being rolled back by undo.\n*/\n\nfunction history() {\n  let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  config = {\n    depth: config.depth || 100,\n    newGroupDelay: config.newGroupDelay || 500\n  };\n  return new Plugin({\n    key: historyKey,\n    state: {\n      init() {\n        return new HistoryState(Branch.empty, Branch.empty, null, 0);\n      },\n\n      apply(tr, hist, state) {\n        return applyTransaction(hist, state, tr, config);\n      }\n\n    },\n    config,\n    props: {\n      handleDOMEvents: {\n        beforeinput(view, e) {\n          let inputType = e.inputType;\n          let command = inputType == \"historyUndo\" ? undo : inputType == \"historyRedo\" ? redo : null;\n          if (!command) return false;\n          e.preventDefault();\n          return command(view.state, view.dispatch);\n        }\n\n      }\n    }\n  });\n}\n/**\nA command function that undoes the last change, if any.\n*/\n\n\nconst undo = (state, dispatch) => {\n  let hist = historyKey.getState(state);\n  if (!hist || hist.done.eventCount == 0) return false;\n  if (dispatch) histTransaction(hist, state, dispatch, false);\n  return true;\n};\n/**\nA command function that redoes the last undone change, if any.\n*/\n\n\nconst redo = (state, dispatch) => {\n  let hist = historyKey.getState(state);\n  if (!hist || hist.undone.eventCount == 0) return false;\n  if (dispatch) histTransaction(hist, state, dispatch, true);\n  return true;\n};\n/**\nThe amount of undoable events available in a given state.\n*/\n\n\nfunction undoDepth(state) {\n  let hist = historyKey.getState(state);\n  return hist ? hist.done.eventCount : 0;\n}\n/**\nThe amount of redoable events available in a given editor state.\n*/\n\n\nfunction redoDepth(state) {\n  let hist = historyKey.getState(state);\n  return hist ? hist.undone.eventCount : 0;\n}\n\nexport { closeHistory, history, redo, redoDepth, undo, undoDepth };","map":{"version":3,"names":["RopeSequence","Mapping","PluginKey","Plugin","max_empty_items","Branch","constructor","items","eventCount","popEvent","state","preserveItems","end","length","next","get","selection","remap","mapFrom","remapping","maps","transform","tr","remaining","addAfter","addBefore","forEach","item","i","step","push","Item","map","slice","maybeStep","doc","mapping","undefined","appendMap","append","reverse","concat","addTransform","histOptions","newItems","oldItems","lastItem","steps","invert","docs","merged","merge","pop","overflow","depth","DEPTH_OVERFLOW","cutOffEvents","from","to","mirrorPos","mirrorOffset","addMaps","array","rebased","rebasedTransform","rebasedCount","rebasedItems","start","Math","max","newUntil","iRebased","pos","getMirror","min","newMaps","branch","emptyItemCount","compress","count","upto","events","getMap","newItem","last","empty","n","cutPoint","other","HistoryState","done","undone","prevRanges","prevTime","applyTransaction","history","options","historyTr","getMeta","historyKey","historyState","closeHistoryKey","appended","redo","mustPreserveItems","rangesFor","newGroup","time","newGroupDelay","isAdjacentTo","mapRanges","getBookmark","docChanged","adjacent","result","_from","_to","ranges","histTransaction","dispatch","spec","config","resolve","added","newHist","setSelection","setMeta","scrollIntoView","cachedPreserveItems","cachedPreserveItemsPlugins","plugins","historyPreserveItems","closeHistory","key","init","apply","hist","props","handleDOMEvents","beforeinput","view","e","inputType","command","undo","preventDefault","getState","undoDepth","redoDepth"],"sources":["/Users/sunny/Desktop/Sunnyjin/22tgthon/frontend/node_modules/prosemirror-history/dist/index.js"],"sourcesContent":["import RopeSequence from 'rope-sequence';\nimport { Mapping } from 'prosemirror-transform';\nimport { PluginKey, Plugin } from 'prosemirror-state';\n\n// ProseMirror's history isn't simply a way to roll back to a previous\n// state, because ProseMirror supports applying changes without adding\n// them to the history (for example during collaboration).\n//\n// To this end, each 'Branch' (one for the undo history and one for\n// the redo history) keeps an array of 'Items', which can optionally\n// hold a step (an actual undoable change), and always hold a position\n// map (which is needed to move changes below them to apply to the\n// current document).\n//\n// An item that has both a step and a selection bookmark is the start\n// of an 'event' — a group of changes that will be undone or redone at\n// once. (It stores only the bookmark, since that way we don't have to\n// provide a document until the selection is actually applied, which\n// is useful when compressing.)\n// Used to schedule history compression\nconst max_empty_items = 500;\nclass Branch {\n    constructor(items, eventCount) {\n        this.items = items;\n        this.eventCount = eventCount;\n    }\n    // Pop the latest event off the branch's history and apply it\n    // to a document transform.\n    popEvent(state, preserveItems) {\n        if (this.eventCount == 0)\n            return null;\n        let end = this.items.length;\n        for (;; end--) {\n            let next = this.items.get(end - 1);\n            if (next.selection) {\n                --end;\n                break;\n            }\n        }\n        let remap, mapFrom;\n        if (preserveItems) {\n            remap = this.remapping(end, this.items.length);\n            mapFrom = remap.maps.length;\n        }\n        let transform = state.tr;\n        let selection, remaining;\n        let addAfter = [], addBefore = [];\n        this.items.forEach((item, i) => {\n            if (!item.step) {\n                if (!remap) {\n                    remap = this.remapping(end, i + 1);\n                    mapFrom = remap.maps.length;\n                }\n                mapFrom--;\n                addBefore.push(item);\n                return;\n            }\n            if (remap) {\n                addBefore.push(new Item(item.map));\n                let step = item.step.map(remap.slice(mapFrom)), map;\n                if (step && transform.maybeStep(step).doc) {\n                    map = transform.mapping.maps[transform.mapping.maps.length - 1];\n                    addAfter.push(new Item(map, undefined, undefined, addAfter.length + addBefore.length));\n                }\n                mapFrom--;\n                if (map)\n                    remap.appendMap(map, mapFrom);\n            }\n            else {\n                transform.maybeStep(item.step);\n            }\n            if (item.selection) {\n                selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;\n                remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);\n                return false;\n            }\n        }, this.items.length, 0);\n        return { remaining: remaining, transform, selection: selection };\n    }\n    // Create a new branch with the given transform added.\n    addTransform(transform, selection, histOptions, preserveItems) {\n        let newItems = [], eventCount = this.eventCount;\n        let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;\n        for (let i = 0; i < transform.steps.length; i++) {\n            let step = transform.steps[i].invert(transform.docs[i]);\n            let item = new Item(transform.mapping.maps[i], step, selection), merged;\n            if (merged = lastItem && lastItem.merge(item)) {\n                item = merged;\n                if (i)\n                    newItems.pop();\n                else\n                    oldItems = oldItems.slice(0, oldItems.length - 1);\n            }\n            newItems.push(item);\n            if (selection) {\n                eventCount++;\n                selection = undefined;\n            }\n            if (!preserveItems)\n                lastItem = item;\n        }\n        let overflow = eventCount - histOptions.depth;\n        if (overflow > DEPTH_OVERFLOW) {\n            oldItems = cutOffEvents(oldItems, overflow);\n            eventCount -= overflow;\n        }\n        return new Branch(oldItems.append(newItems), eventCount);\n    }\n    remapping(from, to) {\n        let maps = new Mapping;\n        this.items.forEach((item, i) => {\n            let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from\n                ? maps.maps.length - item.mirrorOffset : undefined;\n            maps.appendMap(item.map, mirrorPos);\n        }, from, to);\n        return maps;\n    }\n    addMaps(array) {\n        if (this.eventCount == 0)\n            return this;\n        return new Branch(this.items.append(array.map(map => new Item(map))), this.eventCount);\n    }\n    // When the collab module receives remote changes, the history has\n    // to know about those, so that it can adjust the steps that were\n    // rebased on top of the remote changes, and include the position\n    // maps for the remote changes in its array of items.\n    rebased(rebasedTransform, rebasedCount) {\n        if (!this.eventCount)\n            return this;\n        let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);\n        let mapping = rebasedTransform.mapping;\n        let newUntil = rebasedTransform.steps.length;\n        let eventCount = this.eventCount;\n        this.items.forEach(item => { if (item.selection)\n            eventCount--; }, start);\n        let iRebased = rebasedCount;\n        this.items.forEach(item => {\n            let pos = mapping.getMirror(--iRebased);\n            if (pos == null)\n                return;\n            newUntil = Math.min(newUntil, pos);\n            let map = mapping.maps[pos];\n            if (item.step) {\n                let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);\n                let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));\n                if (selection)\n                    eventCount++;\n                rebasedItems.push(new Item(map, step, selection));\n            }\n            else {\n                rebasedItems.push(new Item(map));\n            }\n        }, start);\n        let newMaps = [];\n        for (let i = rebasedCount; i < newUntil; i++)\n            newMaps.push(new Item(mapping.maps[i]));\n        let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);\n        let branch = new Branch(items, eventCount);\n        if (branch.emptyItemCount() > max_empty_items)\n            branch = branch.compress(this.items.length - rebasedItems.length);\n        return branch;\n    }\n    emptyItemCount() {\n        let count = 0;\n        this.items.forEach(item => { if (!item.step)\n            count++; });\n        return count;\n    }\n    // Compressing a branch means rewriting it to push the air (map-only\n    // items) out. During collaboration, these naturally accumulate\n    // because each remote change adds one. The `upto` argument is used\n    // to ensure that only the items below a given level are compressed,\n    // because `rebased` relies on a clean, untouched set of items in\n    // order to associate old items with rebased steps.\n    compress(upto = this.items.length) {\n        let remap = this.remapping(0, upto), mapFrom = remap.maps.length;\n        let items = [], events = 0;\n        this.items.forEach((item, i) => {\n            if (i >= upto) {\n                items.push(item);\n                if (item.selection)\n                    events++;\n            }\n            else if (item.step) {\n                let step = item.step.map(remap.slice(mapFrom)), map = step && step.getMap();\n                mapFrom--;\n                if (map)\n                    remap.appendMap(map, mapFrom);\n                if (step) {\n                    let selection = item.selection && item.selection.map(remap.slice(mapFrom));\n                    if (selection)\n                        events++;\n                    let newItem = new Item(map.invert(), step, selection), merged, last = items.length - 1;\n                    if (merged = items.length && items[last].merge(newItem))\n                        items[last] = merged;\n                    else\n                        items.push(newItem);\n                }\n            }\n            else if (item.map) {\n                mapFrom--;\n            }\n        }, this.items.length, 0);\n        return new Branch(RopeSequence.from(items.reverse()), events);\n    }\n}\nBranch.empty = new Branch(RopeSequence.empty, 0);\nfunction cutOffEvents(items, n) {\n    let cutPoint;\n    items.forEach((item, i) => {\n        if (item.selection && (n-- == 0)) {\n            cutPoint = i;\n            return false;\n        }\n    });\n    return items.slice(cutPoint);\n}\nclass Item {\n    constructor(\n    // The (forward) step map for this item.\n    map, \n    // The inverted step\n    step, \n    // If this is non-null, this item is the start of a group, and\n    // this selection is the starting selection for the group (the one\n    // that was active before the first step was applied)\n    selection, \n    // If this item is the inverse of a previous mapping on the stack,\n    // this points at the inverse's offset\n    mirrorOffset) {\n        this.map = map;\n        this.step = step;\n        this.selection = selection;\n        this.mirrorOffset = mirrorOffset;\n    }\n    merge(other) {\n        if (this.step && other.step && !other.selection) {\n            let step = other.step.merge(this.step);\n            if (step)\n                return new Item(step.getMap().invert(), step, this.selection);\n        }\n    }\n}\n// The value of the state field that tracks undo/redo history for that\n// state. Will be stored in the plugin state when the history plugin\n// is active.\nclass HistoryState {\n    constructor(done, undone, prevRanges, prevTime) {\n        this.done = done;\n        this.undone = undone;\n        this.prevRanges = prevRanges;\n        this.prevTime = prevTime;\n    }\n}\nconst DEPTH_OVERFLOW = 20;\n// Record a transformation in undo history.\nfunction applyTransaction(history, state, tr, options) {\n    let historyTr = tr.getMeta(historyKey), rebased;\n    if (historyTr)\n        return historyTr.historyState;\n    if (tr.getMeta(closeHistoryKey))\n        history = new HistoryState(history.done, history.undone, null, 0);\n    let appended = tr.getMeta(\"appendedTransaction\");\n    if (tr.steps.length == 0) {\n        return history;\n    }\n    else if (appended && appended.getMeta(historyKey)) {\n        if (appended.getMeta(historyKey).redo)\n            return new HistoryState(history.done.addTransform(tr, undefined, options, mustPreserveItems(state)), history.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history.prevTime);\n        else\n            return new HistoryState(history.done, history.undone.addTransform(tr, undefined, options, mustPreserveItems(state)), null, history.prevTime);\n    }\n    else if (tr.getMeta(\"addToHistory\") !== false && !(appended && appended.getMeta(\"addToHistory\") === false)) {\n        // Group transforms that occur in quick succession into one event.\n        let newGroup = history.prevTime == 0 || !appended && (history.prevTime < (tr.time || 0) - options.newGroupDelay ||\n            !isAdjacentTo(tr, history.prevRanges));\n        let prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1]);\n        return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : undefined, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time);\n    }\n    else if (rebased = tr.getMeta(\"rebased\")) {\n        // Used by the collab module to tell the history that some of its\n        // content has been rebased.\n        return new HistoryState(history.done.rebased(tr, rebased), history.undone.rebased(tr, rebased), mapRanges(history.prevRanges, tr.mapping), history.prevTime);\n    }\n    else {\n        return new HistoryState(history.done.addMaps(tr.mapping.maps), history.undone.addMaps(tr.mapping.maps), mapRanges(history.prevRanges, tr.mapping), history.prevTime);\n    }\n}\nfunction isAdjacentTo(transform, prevRanges) {\n    if (!prevRanges)\n        return false;\n    if (!transform.docChanged)\n        return true;\n    let adjacent = false;\n    transform.mapping.maps[0].forEach((start, end) => {\n        for (let i = 0; i < prevRanges.length; i += 2)\n            if (start <= prevRanges[i + 1] && end >= prevRanges[i])\n                adjacent = true;\n    });\n    return adjacent;\n}\nfunction rangesFor(map) {\n    let result = [];\n    map.forEach((_from, _to, from, to) => result.push(from, to));\n    return result;\n}\nfunction mapRanges(ranges, mapping) {\n    if (!ranges)\n        return null;\n    let result = [];\n    for (let i = 0; i < ranges.length; i += 2) {\n        let from = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);\n        if (from <= to)\n            result.push(from, to);\n    }\n    return result;\n}\n// Apply the latest event from one branch to the document and shift the event\n// onto the other branch.\nfunction histTransaction(history, state, dispatch, redo) {\n    let preserveItems = mustPreserveItems(state);\n    let histOptions = historyKey.get(state).spec.config;\n    let pop = (redo ? history.undone : history.done).popEvent(state, preserveItems);\n    if (!pop)\n        return;\n    let selection = pop.selection.resolve(pop.transform.doc);\n    let added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);\n    let newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0);\n    dispatch(pop.transform.setSelection(selection).setMeta(historyKey, { redo, historyState: newHist }).scrollIntoView());\n}\nlet cachedPreserveItems = false, cachedPreserveItemsPlugins = null;\n// Check whether any plugin in the given state has a\n// `historyPreserveItems` property in its spec, in which case we must\n// preserve steps exactly as they came in, so that they can be\n// rebased.\nfunction mustPreserveItems(state) {\n    let plugins = state.plugins;\n    if (cachedPreserveItemsPlugins != plugins) {\n        cachedPreserveItems = false;\n        cachedPreserveItemsPlugins = plugins;\n        for (let i = 0; i < plugins.length; i++)\n            if (plugins[i].spec.historyPreserveItems) {\n                cachedPreserveItems = true;\n                break;\n            }\n    }\n    return cachedPreserveItems;\n}\n/**\nSet a flag on the given transaction that will prevent further steps\nfrom being appended to an existing history event (so that they\nrequire a separate undo command to undo).\n*/\nfunction closeHistory(tr) {\n    return tr.setMeta(closeHistoryKey, true);\n}\nconst historyKey = new PluginKey(\"history\");\nconst closeHistoryKey = new PluginKey(\"closeHistory\");\n/**\nReturns a plugin that enables the undo history for an editor. The\nplugin will track undo and redo stacks, which can be used with the\n[`undo`](https://prosemirror.net/docs/ref/#history.undo) and [`redo`](https://prosemirror.net/docs/ref/#history.redo) commands.\n\nYou can set an `\"addToHistory\"` [metadata\nproperty](https://prosemirror.net/docs/ref/#state.Transaction.setMeta) of `false` on a transaction\nto prevent it from being rolled back by undo.\n*/\nfunction history(config = {}) {\n    config = { depth: config.depth || 100,\n        newGroupDelay: config.newGroupDelay || 500 };\n    return new Plugin({\n        key: historyKey,\n        state: {\n            init() {\n                return new HistoryState(Branch.empty, Branch.empty, null, 0);\n            },\n            apply(tr, hist, state) {\n                return applyTransaction(hist, state, tr, config);\n            }\n        },\n        config,\n        props: {\n            handleDOMEvents: {\n                beforeinput(view, e) {\n                    let inputType = e.inputType;\n                    let command = inputType == \"historyUndo\" ? undo : inputType == \"historyRedo\" ? redo : null;\n                    if (!command)\n                        return false;\n                    e.preventDefault();\n                    return command(view.state, view.dispatch);\n                }\n            }\n        }\n    });\n}\n/**\nA command function that undoes the last change, if any.\n*/\nconst undo = (state, dispatch) => {\n    let hist = historyKey.getState(state);\n    if (!hist || hist.done.eventCount == 0)\n        return false;\n    if (dispatch)\n        histTransaction(hist, state, dispatch, false);\n    return true;\n};\n/**\nA command function that redoes the last undone change, if any.\n*/\nconst redo = (state, dispatch) => {\n    let hist = historyKey.getState(state);\n    if (!hist || hist.undone.eventCount == 0)\n        return false;\n    if (dispatch)\n        histTransaction(hist, state, dispatch, true);\n    return true;\n};\n/**\nThe amount of undoable events available in a given state.\n*/\nfunction undoDepth(state) {\n    let hist = historyKey.getState(state);\n    return hist ? hist.done.eventCount : 0;\n}\n/**\nThe amount of redoable events available in a given editor state.\n*/\nfunction redoDepth(state) {\n    let hist = historyKey.getState(state);\n    return hist ? hist.undone.eventCount : 0;\n}\n\nexport { closeHistory, history, redo, redoDepth, undo, undoDepth };\n"],"mappings":"AAAA,OAAOA,YAAP,MAAyB,eAAzB;AACA,SAASC,OAAT,QAAwB,uBAAxB;AACA,SAASC,SAAT,EAAoBC,MAApB,QAAkC,mBAAlC,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,eAAe,GAAG,GAAxB;;AACA,MAAMC,MAAN,CAAa;EACTC,WAAW,CAACC,KAAD,EAAQC,UAAR,EAAoB;IAC3B,KAAKD,KAAL,GAAaA,KAAb;IACA,KAAKC,UAAL,GAAkBA,UAAlB;EACH,CAJQ,CAKT;EACA;;;EACAC,QAAQ,CAACC,KAAD,EAAQC,aAAR,EAAuB;IAC3B,IAAI,KAAKH,UAAL,IAAmB,CAAvB,EACI,OAAO,IAAP;IACJ,IAAII,GAAG,GAAG,KAAKL,KAAL,CAAWM,MAArB;;IACA,QAAQD,GAAG,EAAX,EAAe;MACX,IAAIE,IAAI,GAAG,KAAKP,KAAL,CAAWQ,GAAX,CAAeH,GAAG,GAAG,CAArB,CAAX;;MACA,IAAIE,IAAI,CAACE,SAAT,EAAoB;QAChB,EAAEJ,GAAF;QACA;MACH;IACJ;;IACD,IAAIK,KAAJ,EAAWC,OAAX;;IACA,IAAIP,aAAJ,EAAmB;MACfM,KAAK,GAAG,KAAKE,SAAL,CAAeP,GAAf,EAAoB,KAAKL,KAAL,CAAWM,MAA/B,CAAR;MACAK,OAAO,GAAGD,KAAK,CAACG,IAAN,CAAWP,MAArB;IACH;;IACD,IAAIQ,SAAS,GAAGX,KAAK,CAACY,EAAtB;IACA,IAAIN,SAAJ,EAAeO,SAAf;IACA,IAAIC,QAAQ,GAAG,EAAf;IAAA,IAAmBC,SAAS,GAAG,EAA/B;IACA,KAAKlB,KAAL,CAAWmB,OAAX,CAAmB,CAACC,IAAD,EAAOC,CAAP,KAAa;MAC5B,IAAI,CAACD,IAAI,CAACE,IAAV,EAAgB;QACZ,IAAI,CAACZ,KAAL,EAAY;UACRA,KAAK,GAAG,KAAKE,SAAL,CAAeP,GAAf,EAAoBgB,CAAC,GAAG,CAAxB,CAAR;UACAV,OAAO,GAAGD,KAAK,CAACG,IAAN,CAAWP,MAArB;QACH;;QACDK,OAAO;QACPO,SAAS,CAACK,IAAV,CAAeH,IAAf;QACA;MACH;;MACD,IAAIV,KAAJ,EAAW;QACPQ,SAAS,CAACK,IAAV,CAAe,IAAIC,IAAJ,CAASJ,IAAI,CAACK,GAAd,CAAf;QACA,IAAIH,IAAI,GAAGF,IAAI,CAACE,IAAL,CAAUG,GAAV,CAAcf,KAAK,CAACgB,KAAN,CAAYf,OAAZ,CAAd,CAAX;QAAA,IAAgDc,GAAhD;;QACA,IAAIH,IAAI,IAAIR,SAAS,CAACa,SAAV,CAAoBL,IAApB,EAA0BM,GAAtC,EAA2C;UACvCH,GAAG,GAAGX,SAAS,CAACe,OAAV,CAAkBhB,IAAlB,CAAuBC,SAAS,CAACe,OAAV,CAAkBhB,IAAlB,CAAuBP,MAAvB,GAAgC,CAAvD,CAAN;UACAW,QAAQ,CAACM,IAAT,CAAc,IAAIC,IAAJ,CAASC,GAAT,EAAcK,SAAd,EAAyBA,SAAzB,EAAoCb,QAAQ,CAACX,MAAT,GAAkBY,SAAS,CAACZ,MAAhE,CAAd;QACH;;QACDK,OAAO;QACP,IAAIc,GAAJ,EACIf,KAAK,CAACqB,SAAN,CAAgBN,GAAhB,EAAqBd,OAArB;MACP,CAVD,MAWK;QACDG,SAAS,CAACa,SAAV,CAAoBP,IAAI,CAACE,IAAzB;MACH;;MACD,IAAIF,IAAI,CAACX,SAAT,EAAoB;QAChBA,SAAS,GAAGC,KAAK,GAAGU,IAAI,CAACX,SAAL,CAAegB,GAAf,CAAmBf,KAAK,CAACgB,KAAN,CAAYf,OAAZ,CAAnB,CAAH,GAA8CS,IAAI,CAACX,SAApE;QACAO,SAAS,GAAG,IAAIlB,MAAJ,CAAW,KAAKE,KAAL,CAAW0B,KAAX,CAAiB,CAAjB,EAAoBrB,GAApB,EAAyB2B,MAAzB,CAAgCd,SAAS,CAACe,OAAV,GAAoBC,MAApB,CAA2BjB,QAA3B,CAAhC,CAAX,EAAkF,KAAKhB,UAAL,GAAkB,CAApG,CAAZ;QACA,OAAO,KAAP;MACH;IACJ,CA7BD,EA6BG,KAAKD,KAAL,CAAWM,MA7Bd,EA6BsB,CA7BtB;IA8BA,OAAO;MAAEU,SAAS,EAAEA,SAAb;MAAwBF,SAAxB;MAAmCL,SAAS,EAAEA;IAA9C,CAAP;EACH,CAzDQ,CA0DT;;;EACA0B,YAAY,CAACrB,SAAD,EAAYL,SAAZ,EAAuB2B,WAAvB,EAAoChC,aAApC,EAAmD;IAC3D,IAAIiC,QAAQ,GAAG,EAAf;IAAA,IAAmBpC,UAAU,GAAG,KAAKA,UAArC;IACA,IAAIqC,QAAQ,GAAG,KAAKtC,KAApB;IAAA,IAA2BuC,QAAQ,GAAG,CAACnC,aAAD,IAAkBkC,QAAQ,CAAChC,MAA3B,GAAoCgC,QAAQ,CAAC9B,GAAT,CAAa8B,QAAQ,CAAChC,MAAT,GAAkB,CAA/B,CAApC,GAAwE,IAA9G;;IACA,KAAK,IAAIe,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGP,SAAS,CAAC0B,KAAV,CAAgBlC,MAApC,EAA4Ce,CAAC,EAA7C,EAAiD;MAC7C,IAAIC,IAAI,GAAGR,SAAS,CAAC0B,KAAV,CAAgBnB,CAAhB,EAAmBoB,MAAnB,CAA0B3B,SAAS,CAAC4B,IAAV,CAAerB,CAAf,CAA1B,CAAX;MACA,IAAID,IAAI,GAAG,IAAII,IAAJ,CAASV,SAAS,CAACe,OAAV,CAAkBhB,IAAlB,CAAuBQ,CAAvB,CAAT,EAAoCC,IAApC,EAA0Cb,SAA1C,CAAX;MAAA,IAAiEkC,MAAjE;;MACA,IAAIA,MAAM,GAAGJ,QAAQ,IAAIA,QAAQ,CAACK,KAAT,CAAexB,IAAf,CAAzB,EAA+C;QAC3CA,IAAI,GAAGuB,MAAP;QACA,IAAItB,CAAJ,EACIgB,QAAQ,CAACQ,GAAT,GADJ,KAGIP,QAAQ,GAAGA,QAAQ,CAACZ,KAAT,CAAe,CAAf,EAAkBY,QAAQ,CAAChC,MAAT,GAAkB,CAApC,CAAX;MACP;;MACD+B,QAAQ,CAACd,IAAT,CAAcH,IAAd;;MACA,IAAIX,SAAJ,EAAe;QACXR,UAAU;QACVQ,SAAS,GAAGqB,SAAZ;MACH;;MACD,IAAI,CAAC1B,aAAL,EACImC,QAAQ,GAAGnB,IAAX;IACP;;IACD,IAAI0B,QAAQ,GAAG7C,UAAU,GAAGmC,WAAW,CAACW,KAAxC;;IACA,IAAID,QAAQ,GAAGE,cAAf,EAA+B;MAC3BV,QAAQ,GAAGW,YAAY,CAACX,QAAD,EAAWQ,QAAX,CAAvB;MACA7C,UAAU,IAAI6C,QAAd;IACH;;IACD,OAAO,IAAIhD,MAAJ,CAAWwC,QAAQ,CAACN,MAAT,CAAgBK,QAAhB,CAAX,EAAsCpC,UAAtC,CAAP;EACH;;EACDW,SAAS,CAACsC,IAAD,EAAOC,EAAP,EAAW;IAChB,IAAItC,IAAI,GAAG,IAAInB,OAAJ,EAAX;IACA,KAAKM,KAAL,CAAWmB,OAAX,CAAmB,CAACC,IAAD,EAAOC,CAAP,KAAa;MAC5B,IAAI+B,SAAS,GAAGhC,IAAI,CAACiC,YAAL,IAAqB,IAArB,IAA6BhC,CAAC,GAAGD,IAAI,CAACiC,YAAT,IAAyBH,IAAtD,GACVrC,IAAI,CAACA,IAAL,CAAUP,MAAV,GAAmBc,IAAI,CAACiC,YADd,GAC6BvB,SAD7C;MAEAjB,IAAI,CAACkB,SAAL,CAAeX,IAAI,CAACK,GAApB,EAAyB2B,SAAzB;IACH,CAJD,EAIGF,IAJH,EAISC,EAJT;IAKA,OAAOtC,IAAP;EACH;;EACDyC,OAAO,CAACC,KAAD,EAAQ;IACX,IAAI,KAAKtD,UAAL,IAAmB,CAAvB,EACI,OAAO,IAAP;IACJ,OAAO,IAAIH,MAAJ,CAAW,KAAKE,KAAL,CAAWgC,MAAX,CAAkBuB,KAAK,CAAC9B,GAAN,CAAUA,GAAG,IAAI,IAAID,IAAJ,CAASC,GAAT,CAAjB,CAAlB,CAAX,EAA+D,KAAKxB,UAApE,CAAP;EACH,CApGQ,CAqGT;EACA;EACA;EACA;;;EACAuD,OAAO,CAACC,gBAAD,EAAmBC,YAAnB,EAAiC;IACpC,IAAI,CAAC,KAAKzD,UAAV,EACI,OAAO,IAAP;IACJ,IAAI0D,YAAY,GAAG,EAAnB;IAAA,IAAuBC,KAAK,GAAGC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAY,KAAK9D,KAAL,CAAWM,MAAX,GAAoBoD,YAAhC,CAA/B;IACA,IAAI7B,OAAO,GAAG4B,gBAAgB,CAAC5B,OAA/B;IACA,IAAIkC,QAAQ,GAAGN,gBAAgB,CAACjB,KAAjB,CAAuBlC,MAAtC;IACA,IAAIL,UAAU,GAAG,KAAKA,UAAtB;IACA,KAAKD,KAAL,CAAWmB,OAAX,CAAmBC,IAAI,IAAI;MAAE,IAAIA,IAAI,CAACX,SAAT,EACzBR,UAAU;IAAK,CADnB,EACqB2D,KADrB;IAEA,IAAII,QAAQ,GAAGN,YAAf;IACA,KAAK1D,KAAL,CAAWmB,OAAX,CAAmBC,IAAI,IAAI;MACvB,IAAI6C,GAAG,GAAGpC,OAAO,CAACqC,SAAR,CAAkB,EAAEF,QAApB,CAAV;MACA,IAAIC,GAAG,IAAI,IAAX,EACI;MACJF,QAAQ,GAAGF,IAAI,CAACM,GAAL,CAASJ,QAAT,EAAmBE,GAAnB,CAAX;MACA,IAAIxC,GAAG,GAAGI,OAAO,CAAChB,IAAR,CAAaoD,GAAb,CAAV;;MACA,IAAI7C,IAAI,CAACE,IAAT,EAAe;QACX,IAAIA,IAAI,GAAGmC,gBAAgB,CAACjB,KAAjB,CAAuByB,GAAvB,EAA4BxB,MAA5B,CAAmCgB,gBAAgB,CAACf,IAAjB,CAAsBuB,GAAtB,CAAnC,CAAX;QACA,IAAIxD,SAAS,GAAGW,IAAI,CAACX,SAAL,IAAkBW,IAAI,CAACX,SAAL,CAAegB,GAAf,CAAmBI,OAAO,CAACH,KAAR,CAAcsC,QAAQ,GAAG,CAAzB,EAA4BC,GAA5B,CAAnB,CAAlC;QACA,IAAIxD,SAAJ,EACIR,UAAU;QACd0D,YAAY,CAACpC,IAAb,CAAkB,IAAIC,IAAJ,CAASC,GAAT,EAAcH,IAAd,EAAoBb,SAApB,CAAlB;MACH,CAND,MAOK;QACDkD,YAAY,CAACpC,IAAb,CAAkB,IAAIC,IAAJ,CAASC,GAAT,CAAlB;MACH;IACJ,CAhBD,EAgBGmC,KAhBH;IAiBA,IAAIQ,OAAO,GAAG,EAAd;;IACA,KAAK,IAAI/C,CAAC,GAAGqC,YAAb,EAA2BrC,CAAC,GAAG0C,QAA/B,EAAyC1C,CAAC,EAA1C,EACI+C,OAAO,CAAC7C,IAAR,CAAa,IAAIC,IAAJ,CAASK,OAAO,CAAChB,IAAR,CAAaQ,CAAb,CAAT,CAAb;;IACJ,IAAIrB,KAAK,GAAG,KAAKA,KAAL,CAAW0B,KAAX,CAAiB,CAAjB,EAAoBkC,KAApB,EAA2B5B,MAA3B,CAAkCoC,OAAlC,EAA2CpC,MAA3C,CAAkD2B,YAAlD,CAAZ;IACA,IAAIU,MAAM,GAAG,IAAIvE,MAAJ,CAAWE,KAAX,EAAkBC,UAAlB,CAAb;IACA,IAAIoE,MAAM,CAACC,cAAP,KAA0BzE,eAA9B,EACIwE,MAAM,GAAGA,MAAM,CAACE,QAAP,CAAgB,KAAKvE,KAAL,CAAWM,MAAX,GAAoBqD,YAAY,CAACrD,MAAjD,CAAT;IACJ,OAAO+D,MAAP;EACH;;EACDC,cAAc,GAAG;IACb,IAAIE,KAAK,GAAG,CAAZ;IACA,KAAKxE,KAAL,CAAWmB,OAAX,CAAmBC,IAAI,IAAI;MAAE,IAAI,CAACA,IAAI,CAACE,IAAV,EACzBkD,KAAK;IAAK,CADd;IAEA,OAAOA,KAAP;EACH,CAlJQ,CAmJT;EACA;EACA;EACA;EACA;EACA;;;EACAD,QAAQ,GAA2B;IAAA,IAA1BE,IAA0B,uEAAnB,KAAKzE,KAAL,CAAWM,MAAQ;IAC/B,IAAII,KAAK,GAAG,KAAKE,SAAL,CAAe,CAAf,EAAkB6D,IAAlB,CAAZ;IAAA,IAAqC9D,OAAO,GAAGD,KAAK,CAACG,IAAN,CAAWP,MAA1D;IACA,IAAIN,KAAK,GAAG,EAAZ;IAAA,IAAgB0E,MAAM,GAAG,CAAzB;IACA,KAAK1E,KAAL,CAAWmB,OAAX,CAAmB,CAACC,IAAD,EAAOC,CAAP,KAAa;MAC5B,IAAIA,CAAC,IAAIoD,IAAT,EAAe;QACXzE,KAAK,CAACuB,IAAN,CAAWH,IAAX;QACA,IAAIA,IAAI,CAACX,SAAT,EACIiE,MAAM;MACb,CAJD,MAKK,IAAItD,IAAI,CAACE,IAAT,EAAe;QAChB,IAAIA,IAAI,GAAGF,IAAI,CAACE,IAAL,CAAUG,GAAV,CAAcf,KAAK,CAACgB,KAAN,CAAYf,OAAZ,CAAd,CAAX;QAAA,IAAgDc,GAAG,GAAGH,IAAI,IAAIA,IAAI,CAACqD,MAAL,EAA9D;QACAhE,OAAO;QACP,IAAIc,GAAJ,EACIf,KAAK,CAACqB,SAAN,CAAgBN,GAAhB,EAAqBd,OAArB;;QACJ,IAAIW,IAAJ,EAAU;UACN,IAAIb,SAAS,GAAGW,IAAI,CAACX,SAAL,IAAkBW,IAAI,CAACX,SAAL,CAAegB,GAAf,CAAmBf,KAAK,CAACgB,KAAN,CAAYf,OAAZ,CAAnB,CAAlC;UACA,IAAIF,SAAJ,EACIiE,MAAM;UACV,IAAIE,OAAO,GAAG,IAAIpD,IAAJ,CAASC,GAAG,CAACgB,MAAJ,EAAT,EAAuBnB,IAAvB,EAA6Bb,SAA7B,CAAd;UAAA,IAAuDkC,MAAvD;UAAA,IAA+DkC,IAAI,GAAG7E,KAAK,CAACM,MAAN,GAAe,CAArF;UACA,IAAIqC,MAAM,GAAG3C,KAAK,CAACM,MAAN,IAAgBN,KAAK,CAAC6E,IAAD,CAAL,CAAYjC,KAAZ,CAAkBgC,OAAlB,CAA7B,EACI5E,KAAK,CAAC6E,IAAD,CAAL,GAAclC,MAAd,CADJ,KAGI3C,KAAK,CAACuB,IAAN,CAAWqD,OAAX;QACP;MACJ,CAfI,MAgBA,IAAIxD,IAAI,CAACK,GAAT,EAAc;QACfd,OAAO;MACV;IACJ,CAzBD,EAyBG,KAAKX,KAAL,CAAWM,MAzBd,EAyBsB,CAzBtB;IA0BA,OAAO,IAAIR,MAAJ,CAAWL,YAAY,CAACyD,IAAb,CAAkBlD,KAAK,CAACiC,OAAN,EAAlB,CAAX,EAA+CyC,MAA/C,CAAP;EACH;;AAvLQ;;AAyLb5E,MAAM,CAACgF,KAAP,GAAe,IAAIhF,MAAJ,CAAWL,YAAY,CAACqF,KAAxB,EAA+B,CAA/B,CAAf;;AACA,SAAS7B,YAAT,CAAsBjD,KAAtB,EAA6B+E,CAA7B,EAAgC;EAC5B,IAAIC,QAAJ;EACAhF,KAAK,CAACmB,OAAN,CAAc,CAACC,IAAD,EAAOC,CAAP,KAAa;IACvB,IAAID,IAAI,CAACX,SAAL,IAAmBsE,CAAC,MAAM,CAA9B,EAAkC;MAC9BC,QAAQ,GAAG3D,CAAX;MACA,OAAO,KAAP;IACH;EACJ,CALD;EAMA,OAAOrB,KAAK,CAAC0B,KAAN,CAAYsD,QAAZ,CAAP;AACH;;AACD,MAAMxD,IAAN,CAAW;EACPzB,WAAW,EACX;EACA0B,GAFW,EAGX;EACAH,IAJW,EAKX;EACA;EACA;EACAb,SARW,EASX;EACA;EACA4C,YAXW,EAWG;IACV,KAAK5B,GAAL,GAAWA,GAAX;IACA,KAAKH,IAAL,GAAYA,IAAZ;IACA,KAAKb,SAAL,GAAiBA,SAAjB;IACA,KAAK4C,YAAL,GAAoBA,YAApB;EACH;;EACDT,KAAK,CAACqC,KAAD,EAAQ;IACT,IAAI,KAAK3D,IAAL,IAAa2D,KAAK,CAAC3D,IAAnB,IAA2B,CAAC2D,KAAK,CAACxE,SAAtC,EAAiD;MAC7C,IAAIa,IAAI,GAAG2D,KAAK,CAAC3D,IAAN,CAAWsB,KAAX,CAAiB,KAAKtB,IAAtB,CAAX;MACA,IAAIA,IAAJ,EACI,OAAO,IAAIE,IAAJ,CAASF,IAAI,CAACqD,MAAL,GAAclC,MAAd,EAAT,EAAiCnB,IAAjC,EAAuC,KAAKb,SAA5C,CAAP;IACP;EACJ;;AAxBM,C,CA0BX;AACA;AACA;;;AACA,MAAMyE,YAAN,CAAmB;EACfnF,WAAW,CAACoF,IAAD,EAAOC,MAAP,EAAeC,UAAf,EAA2BC,QAA3B,EAAqC;IAC5C,KAAKH,IAAL,GAAYA,IAAZ;IACA,KAAKC,MAAL,GAAcA,MAAd;IACA,KAAKC,UAAL,GAAkBA,UAAlB;IACA,KAAKC,QAAL,GAAgBA,QAAhB;EACH;;AANc;;AAQnB,MAAMtC,cAAc,GAAG,EAAvB,C,CACA;;AACA,SAASuC,gBAAT,CAA0BC,OAA1B,EAAmCrF,KAAnC,EAA0CY,EAA1C,EAA8C0E,OAA9C,EAAuD;EACnD,IAAIC,SAAS,GAAG3E,EAAE,CAAC4E,OAAH,CAAWC,UAAX,CAAhB;EAAA,IAAwCpC,OAAxC;EACA,IAAIkC,SAAJ,EACI,OAAOA,SAAS,CAACG,YAAjB;EACJ,IAAI9E,EAAE,CAAC4E,OAAH,CAAWG,eAAX,CAAJ,EACIN,OAAO,GAAG,IAAIN,YAAJ,CAAiBM,OAAO,CAACL,IAAzB,EAA+BK,OAAO,CAACJ,MAAvC,EAA+C,IAA/C,EAAqD,CAArD,CAAV;EACJ,IAAIW,QAAQ,GAAGhF,EAAE,CAAC4E,OAAH,CAAW,qBAAX,CAAf;;EACA,IAAI5E,EAAE,CAACyB,KAAH,CAASlC,MAAT,IAAmB,CAAvB,EAA0B;IACtB,OAAOkF,OAAP;EACH,CAFD,MAGK,IAAIO,QAAQ,IAAIA,QAAQ,CAACJ,OAAT,CAAiBC,UAAjB,CAAhB,EAA8C;IAC/C,IAAIG,QAAQ,CAACJ,OAAT,CAAiBC,UAAjB,EAA6BI,IAAjC,EACI,OAAO,IAAId,YAAJ,CAAiBM,OAAO,CAACL,IAAR,CAAahD,YAAb,CAA0BpB,EAA1B,EAA8Be,SAA9B,EAAyC2D,OAAzC,EAAkDQ,iBAAiB,CAAC9F,KAAD,CAAnE,CAAjB,EAA8FqF,OAAO,CAACJ,MAAtG,EAA8Gc,SAAS,CAACnF,EAAE,CAACc,OAAH,CAAWhB,IAAX,CAAgBE,EAAE,CAACyB,KAAH,CAASlC,MAAT,GAAkB,CAAlC,CAAD,CAAvH,EAA+JkF,OAAO,CAACF,QAAvK,CAAP,CADJ,KAGI,OAAO,IAAIJ,YAAJ,CAAiBM,OAAO,CAACL,IAAzB,EAA+BK,OAAO,CAACJ,MAAR,CAAejD,YAAf,CAA4BpB,EAA5B,EAAgCe,SAAhC,EAA2C2D,OAA3C,EAAoDQ,iBAAiB,CAAC9F,KAAD,CAArE,CAA/B,EAA8G,IAA9G,EAAoHqF,OAAO,CAACF,QAA5H,CAAP;EACP,CALI,MAMA,IAAIvE,EAAE,CAAC4E,OAAH,CAAW,cAAX,MAA+B,KAA/B,IAAwC,EAAEI,QAAQ,IAAIA,QAAQ,CAACJ,OAAT,CAAiB,cAAjB,MAAqC,KAAnD,CAA5C,EAAuG;IACxG;IACA,IAAIQ,QAAQ,GAAGX,OAAO,CAACF,QAAR,IAAoB,CAApB,IAAyB,CAACS,QAAD,KAAcP,OAAO,CAACF,QAAR,GAAmB,CAACvE,EAAE,CAACqF,IAAH,IAAW,CAAZ,IAAiBX,OAAO,CAACY,aAA5C,IAClD,CAACC,YAAY,CAACvF,EAAD,EAAKyE,OAAO,CAACH,UAAb,CADuB,CAAxC;IAEA,IAAIA,UAAU,GAAGU,QAAQ,GAAGQ,SAAS,CAACf,OAAO,CAACH,UAAT,EAAqBtE,EAAE,CAACc,OAAxB,CAAZ,GAA+CqE,SAAS,CAACnF,EAAE,CAACc,OAAH,CAAWhB,IAAX,CAAgBE,EAAE,CAACyB,KAAH,CAASlC,MAAT,GAAkB,CAAlC,CAAD,CAAjF;IACA,OAAO,IAAI4E,YAAJ,CAAiBM,OAAO,CAACL,IAAR,CAAahD,YAAb,CAA0BpB,EAA1B,EAA8BoF,QAAQ,GAAGhG,KAAK,CAACM,SAAN,CAAgB+F,WAAhB,EAAH,GAAmC1E,SAAzE,EAAoF2D,OAApF,EAA6FQ,iBAAiB,CAAC9F,KAAD,CAA9G,CAAjB,EAAyIL,MAAM,CAACgF,KAAhJ,EAAuJO,UAAvJ,EAAmKtE,EAAE,CAACqF,IAAtK,CAAP;EACH,CANI,MAOA,IAAI5C,OAAO,GAAGzC,EAAE,CAAC4E,OAAH,CAAW,SAAX,CAAd,EAAqC;IACtC;IACA;IACA,OAAO,IAAIT,YAAJ,CAAiBM,OAAO,CAACL,IAAR,CAAa3B,OAAb,CAAqBzC,EAArB,EAAyByC,OAAzB,CAAjB,EAAoDgC,OAAO,CAACJ,MAAR,CAAe5B,OAAf,CAAuBzC,EAAvB,EAA2ByC,OAA3B,CAApD,EAAyF+C,SAAS,CAACf,OAAO,CAACH,UAAT,EAAqBtE,EAAE,CAACc,OAAxB,CAAlG,EAAoI2D,OAAO,CAACF,QAA5I,CAAP;EACH,CAJI,MAKA;IACD,OAAO,IAAIJ,YAAJ,CAAiBM,OAAO,CAACL,IAAR,CAAa7B,OAAb,CAAqBvC,EAAE,CAACc,OAAH,CAAWhB,IAAhC,CAAjB,EAAwD2E,OAAO,CAACJ,MAAR,CAAe9B,OAAf,CAAuBvC,EAAE,CAACc,OAAH,CAAWhB,IAAlC,CAAxD,EAAiG0F,SAAS,CAACf,OAAO,CAACH,UAAT,EAAqBtE,EAAE,CAACc,OAAxB,CAA1G,EAA4I2D,OAAO,CAACF,QAApJ,CAAP;EACH;AACJ;;AACD,SAASgB,YAAT,CAAsBxF,SAAtB,EAAiCuE,UAAjC,EAA6C;EACzC,IAAI,CAACA,UAAL,EACI,OAAO,KAAP;EACJ,IAAI,CAACvE,SAAS,CAAC2F,UAAf,EACI,OAAO,IAAP;EACJ,IAAIC,QAAQ,GAAG,KAAf;EACA5F,SAAS,CAACe,OAAV,CAAkBhB,IAAlB,CAAuB,CAAvB,EAA0BM,OAA1B,CAAkC,CAACyC,KAAD,EAAQvD,GAAR,KAAgB;IAC9C,KAAK,IAAIgB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGgE,UAAU,CAAC/E,MAA/B,EAAuCe,CAAC,IAAI,CAA5C,EACI,IAAIuC,KAAK,IAAIyB,UAAU,CAAChE,CAAC,GAAG,CAAL,CAAnB,IAA8BhB,GAAG,IAAIgF,UAAU,CAAChE,CAAD,CAAnD,EACIqF,QAAQ,GAAG,IAAX;EACX,CAJD;EAKA,OAAOA,QAAP;AACH;;AACD,SAASR,SAAT,CAAmBzE,GAAnB,EAAwB;EACpB,IAAIkF,MAAM,GAAG,EAAb;EACAlF,GAAG,CAACN,OAAJ,CAAY,CAACyF,KAAD,EAAQC,GAAR,EAAa3D,IAAb,EAAmBC,EAAnB,KAA0BwD,MAAM,CAACpF,IAAP,CAAY2B,IAAZ,EAAkBC,EAAlB,CAAtC;EACA,OAAOwD,MAAP;AACH;;AACD,SAASJ,SAAT,CAAmBO,MAAnB,EAA2BjF,OAA3B,EAAoC;EAChC,IAAI,CAACiF,MAAL,EACI,OAAO,IAAP;EACJ,IAAIH,MAAM,GAAG,EAAb;;EACA,KAAK,IAAItF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGyF,MAAM,CAACxG,MAA3B,EAAmCe,CAAC,IAAI,CAAxC,EAA2C;IACvC,IAAI6B,IAAI,GAAGrB,OAAO,CAACJ,GAAR,CAAYqF,MAAM,CAACzF,CAAD,CAAlB,EAAuB,CAAvB,CAAX;IAAA,IAAsC8B,EAAE,GAAGtB,OAAO,CAACJ,GAAR,CAAYqF,MAAM,CAACzF,CAAC,GAAG,CAAL,CAAlB,EAA2B,CAAC,CAA5B,CAA3C;IACA,IAAI6B,IAAI,IAAIC,EAAZ,EACIwD,MAAM,CAACpF,IAAP,CAAY2B,IAAZ,EAAkBC,EAAlB;EACP;;EACD,OAAOwD,MAAP;AACH,C,CACD;AACA;;;AACA,SAASI,eAAT,CAAyBvB,OAAzB,EAAkCrF,KAAlC,EAAyC6G,QAAzC,EAAmDhB,IAAnD,EAAyD;EACrD,IAAI5F,aAAa,GAAG6F,iBAAiB,CAAC9F,KAAD,CAArC;EACA,IAAIiC,WAAW,GAAGwD,UAAU,CAACpF,GAAX,CAAeL,KAAf,EAAsB8G,IAAtB,CAA2BC,MAA7C;EACA,IAAIrE,GAAG,GAAG,CAACmD,IAAI,GAAGR,OAAO,CAACJ,MAAX,GAAoBI,OAAO,CAACL,IAAjC,EAAuCjF,QAAvC,CAAgDC,KAAhD,EAAuDC,aAAvD,CAAV;EACA,IAAI,CAACyC,GAAL,EACI;EACJ,IAAIpC,SAAS,GAAGoC,GAAG,CAACpC,SAAJ,CAAc0G,OAAd,CAAsBtE,GAAG,CAAC/B,SAAJ,CAAcc,GAApC,CAAhB;EACA,IAAIwF,KAAK,GAAG,CAACpB,IAAI,GAAGR,OAAO,CAACL,IAAX,GAAkBK,OAAO,CAACJ,MAA/B,EAAuCjD,YAAvC,CAAoDU,GAAG,CAAC/B,SAAxD,EAAmEX,KAAK,CAACM,SAAN,CAAgB+F,WAAhB,EAAnE,EAAkGpE,WAAlG,EAA+GhC,aAA/G,CAAZ;EACA,IAAIiH,OAAO,GAAG,IAAInC,YAAJ,CAAiBc,IAAI,GAAGoB,KAAH,GAAWvE,GAAG,CAAC7B,SAApC,EAA+CgF,IAAI,GAAGnD,GAAG,CAAC7B,SAAP,GAAmBoG,KAAtE,EAA6E,IAA7E,EAAmF,CAAnF,CAAd;EACAJ,QAAQ,CAACnE,GAAG,CAAC/B,SAAJ,CAAcwG,YAAd,CAA2B7G,SAA3B,EAAsC8G,OAAtC,CAA8C3B,UAA9C,EAA0D;IAAEI,IAAF;IAAQH,YAAY,EAAEwB;EAAtB,CAA1D,EAA2FG,cAA3F,EAAD,CAAR;AACH;;AACD,IAAIC,mBAAmB,GAAG,KAA1B;AAAA,IAAiCC,0BAA0B,GAAG,IAA9D,C,CACA;AACA;AACA;AACA;;AACA,SAASzB,iBAAT,CAA2B9F,KAA3B,EAAkC;EAC9B,IAAIwH,OAAO,GAAGxH,KAAK,CAACwH,OAApB;;EACA,IAAID,0BAA0B,IAAIC,OAAlC,EAA2C;IACvCF,mBAAmB,GAAG,KAAtB;IACAC,0BAA0B,GAAGC,OAA7B;;IACA,KAAK,IAAItG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGsG,OAAO,CAACrH,MAA5B,EAAoCe,CAAC,EAArC,EACI,IAAIsG,OAAO,CAACtG,CAAD,CAAP,CAAW4F,IAAX,CAAgBW,oBAApB,EAA0C;MACtCH,mBAAmB,GAAG,IAAtB;MACA;IACH;EACR;;EACD,OAAOA,mBAAP;AACH;AACD;AACA;AACA;AACA;AACA;;;AACA,SAASI,YAAT,CAAsB9G,EAAtB,EAA0B;EACtB,OAAOA,EAAE,CAACwG,OAAH,CAAWzB,eAAX,EAA4B,IAA5B,CAAP;AACH;;AACD,MAAMF,UAAU,GAAG,IAAIjG,SAAJ,CAAc,SAAd,CAAnB;AACA,MAAMmG,eAAe,GAAG,IAAInG,SAAJ,CAAc,cAAd,CAAxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAAS6F,OAAT,GAA8B;EAAA,IAAb0B,MAAa,uEAAJ,EAAI;EAC1BA,MAAM,GAAG;IAAEnE,KAAK,EAAEmE,MAAM,CAACnE,KAAP,IAAgB,GAAzB;IACLsD,aAAa,EAAEa,MAAM,CAACb,aAAP,IAAwB;EADlC,CAAT;EAEA,OAAO,IAAIzG,MAAJ,CAAW;IACdkI,GAAG,EAAElC,UADS;IAEdzF,KAAK,EAAE;MACH4H,IAAI,GAAG;QACH,OAAO,IAAI7C,YAAJ,CAAiBpF,MAAM,CAACgF,KAAxB,EAA+BhF,MAAM,CAACgF,KAAtC,EAA6C,IAA7C,EAAmD,CAAnD,CAAP;MACH,CAHE;;MAIHkD,KAAK,CAACjH,EAAD,EAAKkH,IAAL,EAAW9H,KAAX,EAAkB;QACnB,OAAOoF,gBAAgB,CAAC0C,IAAD,EAAO9H,KAAP,EAAcY,EAAd,EAAkBmG,MAAlB,CAAvB;MACH;;IANE,CAFO;IAUdA,MAVc;IAWdgB,KAAK,EAAE;MACHC,eAAe,EAAE;QACbC,WAAW,CAACC,IAAD,EAAOC,CAAP,EAAU;UACjB,IAAIC,SAAS,GAAGD,CAAC,CAACC,SAAlB;UACA,IAAIC,OAAO,GAAGD,SAAS,IAAI,aAAb,GAA6BE,IAA7B,GAAoCF,SAAS,IAAI,aAAb,GAA6BvC,IAA7B,GAAoC,IAAtF;UACA,IAAI,CAACwC,OAAL,EACI,OAAO,KAAP;UACJF,CAAC,CAACI,cAAF;UACA,OAAOF,OAAO,CAACH,IAAI,CAAClI,KAAN,EAAakI,IAAI,CAACrB,QAAlB,CAAd;QACH;;MARY;IADd;EAXO,CAAX,CAAP;AAwBH;AACD;AACA;AACA;;;AACA,MAAMyB,IAAI,GAAG,CAACtI,KAAD,EAAQ6G,QAAR,KAAqB;EAC9B,IAAIiB,IAAI,GAAGrC,UAAU,CAAC+C,QAAX,CAAoBxI,KAApB,CAAX;EACA,IAAI,CAAC8H,IAAD,IAASA,IAAI,CAAC9C,IAAL,CAAUlF,UAAV,IAAwB,CAArC,EACI,OAAO,KAAP;EACJ,IAAI+G,QAAJ,EACID,eAAe,CAACkB,IAAD,EAAO9H,KAAP,EAAc6G,QAAd,EAAwB,KAAxB,CAAf;EACJ,OAAO,IAAP;AACH,CAPD;AAQA;AACA;AACA;;;AACA,MAAMhB,IAAI,GAAG,CAAC7F,KAAD,EAAQ6G,QAAR,KAAqB;EAC9B,IAAIiB,IAAI,GAAGrC,UAAU,CAAC+C,QAAX,CAAoBxI,KAApB,CAAX;EACA,IAAI,CAAC8H,IAAD,IAASA,IAAI,CAAC7C,MAAL,CAAYnF,UAAZ,IAA0B,CAAvC,EACI,OAAO,KAAP;EACJ,IAAI+G,QAAJ,EACID,eAAe,CAACkB,IAAD,EAAO9H,KAAP,EAAc6G,QAAd,EAAwB,IAAxB,CAAf;EACJ,OAAO,IAAP;AACH,CAPD;AAQA;AACA;AACA;;;AACA,SAAS4B,SAAT,CAAmBzI,KAAnB,EAA0B;EACtB,IAAI8H,IAAI,GAAGrC,UAAU,CAAC+C,QAAX,CAAoBxI,KAApB,CAAX;EACA,OAAO8H,IAAI,GAAGA,IAAI,CAAC9C,IAAL,CAAUlF,UAAb,GAA0B,CAArC;AACH;AACD;AACA;AACA;;;AACA,SAAS4I,SAAT,CAAmB1I,KAAnB,EAA0B;EACtB,IAAI8H,IAAI,GAAGrC,UAAU,CAAC+C,QAAX,CAAoBxI,KAApB,CAAX;EACA,OAAO8H,IAAI,GAAGA,IAAI,CAAC7C,MAAL,CAAYnF,UAAf,GAA4B,CAAvC;AACH;;AAED,SAAS4H,YAAT,EAAuBrC,OAAvB,EAAgCQ,IAAhC,EAAsC6C,SAAtC,EAAiDJ,IAAjD,EAAuDG,SAAvD"},"metadata":{},"sourceType":"module"}